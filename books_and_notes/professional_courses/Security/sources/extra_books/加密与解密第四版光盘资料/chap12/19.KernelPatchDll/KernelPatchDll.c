/*-----------------------------------------------------------------------
第12章  注入技术
《加密与解密（第四版）》
(c)  看雪学院 www.kanxue.com 2000-2018
-----------------------------------------------------------------------*/

/*

  KernelPatchDll.C

  Author: achillis
  Last Updated: 2006-03-23

  This framework is generated by EasySYS 0.3.0
  This template file is copying from QuickSYS 0.3.0 written by Chunhua Liu

*/

#include "dbghelp.h"
#include "KernelPatchDll.h"
#include "ntifs.h"
#include "Common.h"
#include <ntimage.h>

// Device driver routine declarations.
//

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	);

NTSTATUS
KernelpatchdllDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
KernelpatchdllDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
KernelpatchdllDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

VOID
KernelpatchdllUnload(
	IN PDRIVER_OBJECT		DriverObject
	);

typedef NTSTATUS
(*PFN_ZwProtectVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	PSIZE_T RegionSize,
	ULONG NewProtectWin32,
	PULONG OldProtect
	);

ULONG GetZwProtectMemoryAddr();

VOID
MyLoadImageRoutine(
	IN PUNICODE_STRING  FullImageName,
	IN HANDLE  ProcessId, // where image is mapped
	IN PIMAGE_INFO  ImageInfo
	);

NTSTATUS PatchDllEntryByMdl(ULONG_PTR ImageBase);
BOOL IsDeniedModule(PUNICODE_STRING  FullImageName);
BOOL InitGlobalVars();

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, KernelpatchdllDispatchCreate)
#pragma alloc_text(PAGE, KernelpatchdllDispatchClose)
#pragma alloc_text(PAGE, KernelpatchdllDispatchDeviceControl)
#pragma alloc_text(PAGE, KernelpatchdllUnload)
#endif // ALLOC_PRAGMA


//Notify
BOOL g_IsImageNotifyInstalled=FALSE;
PFN_ZwProtectVirtualMemory pfnZwProtectVirtualMemory;
//尽量短一些
char g_szDllToInject[256]="C:\\MsgDll.dll";
char g_szDllExportFun[256]="Msg";
ULONG g_AddressLockOffset = 0xF0;

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	)
{
	//
    // Create dispatch points for device control, create, close.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = KernelpatchdllDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = KernelpatchdllDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = KernelpatchdllDispatchDeviceControl;
    DriverObject->DriverUnload                         = KernelpatchdllUnload;
	
	InitGlobalVars();
	PsSetLoadImageNotifyRoutine(MyLoadImageRoutine);
	DbgPrint("[KernelPatchDll] Loaded!\n");
    return STATUS_SUCCESS;
}

NTSTATUS
KernelpatchdllDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[KernelPatchDll] IRP_MJ_CREATE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
KernelpatchdllDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[KernelPatchDll] IRP_MJ_CLOSE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
KernelpatchdllDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	dprintf("[KernelPatchDll] IRP_MJ_DEVICE_CONTROL\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

VOID
KernelpatchdllUnload(
	IN PDRIVER_OBJECT		DriverObject
	)
{
	PsRemoveLoadImageNotifyRoutine(MyLoadImageRoutine);
    DbgPrint("[KernelPatchDll] Unloaded\n");
}

BOOL InitGlobalVars()
{
	NTSTATUS status;
	UNICODE_STRING usDrvName;
	HANDLE CsrssPid;
	//初始化
	
	pfnZwProtectVirtualMemory=(PFN_ZwProtectVirtualMemory)GetZwProtectVirtualMemoryAddr();
	if (pfnZwProtectVirtualMemory==NULL)
	{
		DbgPrint("无法获取ZwProtectVirtualMemory的地址!\n");
		return FALSE;
	}
	else
	{
		DbgPrint("ZwProtectVirtualMemory Addr=0x%08X\n",pfnZwProtectVirtualMemory);
	}
	return TRUE;
}

VOID
MyLoadImageRoutine(
	IN PUNICODE_STRING  FullImageName,
	IN HANDLE  ProcessId, // where image is mapped
	IN PIMAGE_INFO  ImageInfo
	)
{
	NTSTATUS status;
	PEPROCESS TargetProcess , CurProcess ;
	BOOL bAttach = FALSE ;
	
	if (ProcessId!=NULL)//用户进程
	{
		//检查当前模块是否被禁止加载
		if (IsDeniedModule(FullImageName))
		{
			CurProcess = PsGetCurrentProcess();
			status = PsLookupProcessByProcessId(ProcessId,&TargetProcess);
			if (NT_SUCCESS(status))
			{
				if (CurProcess != TargetProcess)
				{
					KeAttachProcess(TargetProcess);
					bAttach = TRUE ;
				}

				DbgPrint("准备PatchDll!\n");
				status=PatchDllEntryByMdl((ULONG_PTR)ImageInfo->ImageBase);
				if (bAttach)
				{
					KeDetachProcess();
				}
				
			}
			
		}
	}
}

//检查当前模块是否需要阻止
BOOL IsDeniedModule(PUNICODE_STRING  FullImageName)
{
	WCHAR wImagePath[MAX_PATH] = {0};
	WCHAR *pImageName = NULL ;

	__try
	{
		if (FullImageName != NULL
			&& FullImageName->Buffer != NULL)
		{
			wcsncpy(wImagePath,FullImageName->Buffer,FullImageName->Length);
			pImageName = wcsrchr(wImagePath,'\\');
			pImageName = (pImageName == NULL) ? wImagePath : (pImageName + 1) ;
			if (_wcsicmp(pImageName,L"MsgDll.dll") == 0)
			{
				return TRUE;
			}
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		//发生异常，那么直接放行
		return FALSE;
	}
	
	
	return FALSE;
	
}

NTSTATUS PatchDllEntryByMdl(ULONG_PTR ImageBase)
{
	
	PIMAGE_DOS_HEADER pDosHeader;
	PIMAGE_NT_HEADERS pNtHeader;
	PIMAGE_FILE_HEADER pFileHeader;
	PIMAGE_OPTIONAL_HEADER pOptHeader;
	ULONG OldProtect;
	NTSTATUS status;
	PVOID AddresstoChangeProtect=0;
	ULONG SizeToChangeProtect=0;
	BYTE DenyCode[8]= "\x33\xC0\xC2\x0C\x00";//return 0
	ULONG_PTR DllEntry = 0 ;
	BYTE* pNewEntry = NULL ;
	PMDL pMdl = NULL;
	
	//检查参数
	if (ImageBase == 0)
	{
		return STATUS_INVALID_PARAMETER;
	}
	//检查映像
	pDosHeader = (PIMAGE_DOS_HEADER)ImageBase;
	if (pDosHeader->e_magic  != 0x5A4D)	//MZ
	{
		return STATUS_INVALID_IMAGE_NOT_MZ;
	}
	pNtHeader=(PIMAGE_NT_HEADERS)(ImageBase+pDosHeader->e_lfanew);
	if (pNtHeader->Signature != 0x00004550)	//PE
	{
		return STATUS_INVALID_IMAGE_FORMAT;
	}
	__try
	{
		pFileHeader=(PIMAGE_FILE_HEADER)(ImageBase+pDosHeader->e_lfanew+4);
		pOptHeader=(PIMAGE_OPTIONAL_HEADER)((BYTE*)pFileHeader+sizeof(IMAGE_FILE_HEADER));
		DllEntry = ImageBase + pOptHeader->AddressOfEntryPoint ;
		
		DbgPrint("DllEntry = 0x%p\n",DllEntry);
		
		//修改PE头的页属性
		AddresstoChangeProtect = (PVOID)DllEntry ;
		SizeToChangeProtect = 8;
		DbgPrint("修改DllEntry 的页保护属性，Addr=0x%p  Size=0x%X\n",AddresstoChangeProtect,SizeToChangeProtect);
		
		//在Notify中使用ZwProtectVirtualMemory会失败或卡死(EPROCESS->AddressCreationLock被锁)
		//这里使用Mdl来改写内存属性
		pMdl = MapUserModeAddrWritable(AddresstoChangeProtect,SizeToChangeProtect,&pNewEntry);
		if (pMdl != NULL && pNewEntry != NULL)
		{
			DbgPrint("Mapped DllEntry = 0x%p\n" , pNewEntry);
			//Patch
			memcpy(pNewEntry,DenyCode,5);
			DbgPrint("Dll入口Patch完成!\n");
			UnmapMemory(pNewEntry,pMdl);
			return STATUS_SUCCESS;
		}
		else
		{
			DbgPrint("ReMap DllEntry Failed!\n");
			return STATUS_UNSUCCESSFUL;
		}
	}__except(EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint("发生内存读写错误!\n");
		return GetExceptionCode();
	}	
}
