/*-----------------------------------------------------------------------
第12章  注入技术
《加密与解密（第四版）》
(c)  看雪学院 www.kanxue.com 2000-2018
-----------------------------------------------------------------------*/

/*

  AntiDllInject.C

  Author: achillis
  Last Updated: 2006-03-23

  This framework is generated by EasySYS 0.3.0
  This template file is copying from QuickSYS 0.3.0 written by Chunhua Liu

*/

#include "dbghelp.h"
#include "AntiDllInject.h"
#include "myKernel.h"
#include "ntifs.h"
#include <ntimage.h>

// Device driver routine declarations.
//

//通用结构,下面的16进制分别表示该结构在x86_x64平台上的偏移量
typedef struct _USERHOOK
{
	/*off=0x00_00*/DWORD      dwBufferSize;		//本结构及附加数据的总大小
	/*off=0x04_04*/DWORD      dwAdditionalData; //指本结构之后有多少附加数据，一般是路径,按字长对齐
	/*off=0x08_08*/ULONG_PTR  dwFixupsCount;	//有几个地址需要修正
	/*off=0x0C_10*/LPVOID     pbFree;			//不明
	/*off=0x10_18*/ULONG_PTR  offCbkPtrs;		//指向要修正的偏移地址存放的位置
	/*off=0x14_20*/ULONG_PTR  bFixed;			//修正标志
	/*off=0x18_28*/UNICODE_STRING lpDLLPath;	//Dll路径,Buffer可能需要修正
	//省略了一部分内容
	/*off=0x20*///ULONG      lpfnNotifyOffset;  //HookProc相对于模块基址的偏移
	/*off=0x24*///DWORD      offCbk[1];			//需要修正的数据在本结构中的偏移
} USERHOOK;

typedef NTSTATUS
(*PKE_USERMODE_CALLBACK)(
	ULONG ApiNumber,
	PVOID InputBuffer,
	ULONG InputLength,
	PVOID *OutputBuffer,
	PULONG OutputLength
	);

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	);

NTSTATUS
AntidllinjectDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
AntidllinjectDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
AntidllinjectDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

VOID
AntidllinjectUnload(
	IN PDRIVER_OBJECT		DriverObject
	);


//安装导入表钩子
LONG InstallImportTableHook(
	ULONG ImageBase,
	ULONG ModuleSize,
	char *RoutineName,
	char *ImportModuleName,
	ULONG HookFunAddr,
	ULONG *OriginalAddrInIAT
	);

NTSTATUS
Fake_KeUserModeCallback(
	ULONG ApiNumber,
	PVOID InputBuffer,
	ULONG InputLength,
	PVOID *OutputBuffer,
	PULONG OutputLength
	);
//初始化数据
BOOL InitGlobalVars();
//卸载钩子
VOID UnInstallKeUserModeCallbackHook();
//获取指定内核模块的基址和映像大小
BOOL GetModuleBaseAndSize(char *ModuleName, PULONG PointerToBase, PULONG PointerToSize);
//为win32k.sys安装IAT钩子，钩住KeUserModeCallback防全局钩子入侵
LONG InstallKeUserModeCallbackHook(ULONG ModuleBase, ULONG ModuleSize);
//获取Csrss.exe的EPROCESS
PEPROCESS GetProcessBySpecialObjName(UCHAR ObjTypeIndex,WCHAR *wsObjName);
void FixupCallbackPointers(USERHOOK *pData);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, AntidllinjectDispatchCreate)
#pragma alloc_text(PAGE, AntidllinjectDispatchClose)
#pragma alloc_text(PAGE, AntidllinjectDispatchDeviceControl)
#pragma alloc_text(PAGE, AntidllinjectUnload)
#endif // ALLOC_PRAGMA


WCHAR g_CsrssApiPortName[]=L"\\Windows\\ApiPort";
PEPROCESS g_CsrssProcess=NULL;
PKE_USERMODE_CALLBACK Original_KeUserModeCallBack;
ULONG g_Win32kBase;
ULONG g_Win32kSize;
LONG g_AddressPointerInIAT=0;
ULONG g_Cnt = 0 ;
BOOL g_bEnableShow = FALSE ;
ULONG g_IndexOfCallBack = 0x42 ;

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	)
{
	//
    // Create dispatch points for device control, create, close.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = AntidllinjectDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = AntidllinjectDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = AntidllinjectDispatchDeviceControl;
    DriverObject->DriverUnload                         = AntidllinjectUnload;

	if (!InitGlobalVars())
	{
		dprintf("初始化数据失败!\n");
	}
	else
	{
		InstallKeUserModeCallbackHook(g_Win32kBase,g_Win32kSize);
	}
	DbgPrint("[AntiDllInject] Loaded!\n");
    return STATUS_SUCCESS;
}

NTSTATUS
AntidllinjectDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[AntiDllInject] IRP_MJ_CREATE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
AntidllinjectDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[AntiDllInject] IRP_MJ_CLOSE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
AntidllinjectDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	dprintf("[AntiDllInject] IRP_MJ_DEVICE_CONTROL\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

VOID
AntidllinjectUnload(
	IN PDRIVER_OBJECT		DriverObject
	)
{
    if (g_AddressPointerInIAT)
    {
		UnInstallKeUserModeCallbackHook();
    }
	
	DbgPrint("[AntiDllInject] Unloaded\n");
}


BOOL GetModuleBaseAndSize(char *ModuleName, PULONG PointerToBase, PULONG PointerToSize)
{
	PVOID pBuf=NULL;
	SIZE_T bufferlen=0x1000; 
	NTSTATUS status;
	BOOL result;
	char *p;
	char *CurImageName;
	char *szModuleName;
	ULONG ReturnLength;
	ULONG ModuleCnt; 
	ULONG i; 
	PSYSTEM_MODULE_INFORMATION pModuleInfo;
	
	do
	{
		if ( pBuf ) //若pBuf不为NULL，则先释放之
			ExFreePool(pBuf);
		pBuf = ExAllocatePool(NonPagedPool, bufferlen);
		
		if ( !pBuf )
			return FALSE;
		
		status = ZwQuerySystemInformation(SystemModuleInformation, pBuf, bufferlen, &ReturnLength);
		if ( !NT_SUCCESS(status) && status != STATUS_INFO_LENGTH_MISMATCH )
		{
			result = 0;
			ExFreePool(pBuf);
			return result;
		}
		bufferlen += 0x1000;
	}
	while ( !NT_SUCCESS(status) );
	
	ModuleCnt = *(ULONG *)pBuf;
	pModuleInfo = (PSYSTEM_MODULE_INFORMATION)((char *)pBuf + 4);
	if ( !ModuleName )//传入的模块名称为NULL时，是为了获取内核的基址和大小
	{
		*PointerToBase = (ULONG) pModuleInfo->Base;
		*PointerToSize = pModuleInfo->Size;
		result = TRUE;
		ExFreePool(pBuf);
		return result;
	}
	i = 0;
	if ( ModuleCnt )
	{
		while ( 1 )
		{
			szModuleName = pModuleInfo->ImageName;
			p = strrchr(szModuleName, '\\');
			if ( p )
				CurImageName = p + 1;
			else
				CurImageName = szModuleName;
			if ( !_stricmp(CurImageName, ModuleName) )//匹配模块名称
				break;
			pModuleInfo++;
			++i;
			if ( i >= ModuleCnt )
			{
				result = FALSE;
				return result;
			}
		}
		*PointerToBase = (ULONG) pModuleInfo->Base;
		*PointerToSize = pModuleInfo->Size;
		ExFreePool(pBuf);
		result = TRUE;
	}
	else
	{
		result = FALSE;
	}
	return result;
}



LONG InstallImportTableHook(
	ULONG ImageBase,
	ULONG ModuleSize,
	char *targetFunName,
	char *ImportModuleName,
	ULONG HookFunAddr,
	ULONG *OriginalAddrInIAT)
{
	char *ModuleBase;
	PIMAGE_DOS_HEADER pDosHeader;
	PIMAGE_NT_HEADERS pNtHeader;
	PIMAGE_OPTIONAL_HEADER pOptHeader;
	PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor;
	PIMAGE_THUNK_DATA         pThunkData;
	PIMAGE_DATA_DIRECTORY pImageDataDir;
	char * funname;
	PULONG lpAddr;
	ULONG result;
	int num=1;
	
	ModuleBase=(char*)ImageBase;
	pDosHeader=(PIMAGE_DOS_HEADER)ModuleBase;
	if (  ModuleSize >= 0x40 && *(WORD*)ModuleBase == 0x5A4D && ModuleSize >= ( (ULONG)pDosHeader->e_lfanew + 0xF8) ) //MZ?
	{
		pNtHeader=(PIMAGE_NT_HEADERS)(ModuleBase+pDosHeader->e_lfanew);
        if ( *(ULONG *)pNtHeader == 0x4550 ) //PE?
        {
			pOptHeader=(PIMAGE_OPTIONAL_HEADER)((char*)pNtHeader+4+sizeof(IMAGE_FILE_HEADER));
			pImageDataDir=& pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
			if ( pImageDataDir->VirtualAddress && pImageDataDir->Size)
			{
				pImportDescriptor=(PIMAGE_IMPORT_DESCRIPTOR)(ModuleBase+pImageDataDir->VirtualAddress);
				while ( pImportDescriptor->FirstThunk)
				{
					if ( !ImportModuleName || !_stricmp(ModuleBase+pImportDescriptor->Name, ImportModuleName) )
					{
						pThunkData = (PIMAGE_THUNK_DATA)(ModuleBase + pImportDescriptor->OriginalFirstThunk);
						num=1;
						while(pThunkData->u1.Function)
						{
							funname = (char *)( (ULONG)pThunkData->u1.AddressOfData + 2);
							if ( !targetFunName || !_stricmp(funname, targetFunName) )
							{
								lpAddr = (ULONG *)( ModuleBase + (ULONG)pImportDescriptor->FirstThunk) +(num-1);
								if ( HookFunAddr )
								{
									WPOFF();
									result=InterlockedExchange((volatile LONG *)lpAddr, HookFunAddr);
									WPON();
								}
								result=*lpAddr;
								*OriginalAddrInIAT = (ULONG)lpAddr;
								return result;
							}
							num++;
							pThunkData++;
						}
					}
                    pImportDescriptor++;
                }
            }
        }
    }
	return 0;
}

LONG InstallKeUserModeCallbackHook(ULONG ModuleBase, ULONG ModuleSize)
{
	LONG result;
	
	if (g_CsrssProcess)
	{
		KeAttachProcess(g_CsrssProcess);
		result = InstallImportTableHook(ModuleBase, 
			ModuleSize,
			"KeUserModeCallback",
			"ntoskrnl.exe", 
			0, 
			&g_AddressPointerInIAT);
		if ( result )
		{
			Original_KeUserModeCallBack = (PKE_USERMODE_CALLBACK)result;
				
			WPOFF();
			result = InterlockedExchange((LONG*)g_AddressPointerInIAT, (LONG)Fake_KeUserModeCallback);
			WPON();
			dprintf("[AntiDllInject] 安装钩子成功！\n");
			
		}
		KeDetachProcess();
	}
	return result;
}

VOID UnInstallKeUserModeCallbackHook()
{
	const LARGE_INTEGER ThreeSecond = {(ULONG)(-3 * 1000 * 1000 * 10), -1};
	if (g_CsrssProcess)
	{
		//先卸载Hook,但不返回，否则会BSOD
		KeAttachProcess(g_CsrssProcess);
		WPOFF();
		InterlockedExchange((LONG*)g_AddressPointerInIAT, (LONG)Original_KeUserModeCallBack);
		WPON();
		KeDetachProcess();
		DbgPrint("[AntiDllInject] 卸载钩子成功！等待所有调用完成...\n");
		
		//允许打印
		g_bEnableShow = TRUE;
		while (g_Cnt != 0)
		{
			dprintf("[AntiDllInject] CallCnt = %d , 等待3秒再卸载...\n",g_Cnt);
			KeDelayExecutionThread(KernelMode,FALSE,(LARGE_INTEGER*)&ThreeSecond);
		}
		DbgPrint("[AntiDllInject] 所有调用全部完成,现在可以安全卸载!\n");
		
	}
	
}

BOOL InitGlobalVars()
{
	DWORD dwBuildNum =0 ;
	BOOL bRet=FALSE;
	//获取CsrssProcess
	g_CsrssProcess=GetProcessBySpecialObjName(0x15,g_CsrssApiPortName);
	dprintf("CsrssProc=0x%08X\n",g_CsrssProcess);
	bRet=GetModuleBaseAndSize("win32k.sys", &g_Win32kBase, &g_Win32kSize);
	if (bRet==FALSE)
	{
		dprintf("Could not get Module info of win32k.sys");
		return FALSE;
	}
	dprintf("[AntiDllInject] win32k.sys Base=0x%08X\tSize=0x%08X\n",g_Win32kBase,g_Win32kSize);

	//初始化
	PsGetVersion(NULL,NULL,&dwBuildNum,NULL);
	switch(dwBuildNum)
	{
	case 2600:
	case 3790:
		g_IndexOfCallBack = 0x42 ;
		break;
	case 6000:
	case 7600:
	case 7601:
		g_IndexOfCallBack = 0x41 ;
	    break;
	case 9200:
	    break;
	case 10240:
	    break;
	default:
	    break;
	}
	return bRet;
}

PEPROCESS GetProcessBySpecialObjName(UCHAR ObjTypeIndex,WCHAR *wsObjName)
{
  char* pBuf; 
  PSYSTEM_HANDLE_INFORMATION pSysHandleInfo; 
  DWORD HandleCount; 
  HANDLE ProcessId=NULL; 
  DWORD cnt; 
  OBJECT_ATTRIBUTES ObjAttribute; 
  CLIENT_ID ClientId; 
  HANDLE hSourceProcess; 
  HANDLE HandleNew; 
  char ObjectInformation[0x400]; 
  PUNICODE_STRING namebuffer;
  BOOL bFound=FALSE;//自己加的标志
  ULONG buflen=0x4000;
  PEPROCESS ResultProcess=NULL;
  NTSTATUS status;
  while ( 1 )
  {
	  pBuf = ExAllocatePool(PagedPool, buflen);
	  //这里稍有改动,应是先判断再清零
	  if ( !pBuf )
		  break;
	  memset(pBuf, 0, buflen);
	  status = ZwQuerySystemInformation(SystemHandleInformation, pBuf, buflen, 0);
	  if (!NT_SUCCESS(status))
	  {
		  //不成功的原因
		  //dprintf("status=0x%08X\n",status);
		  if ( status == STATUS_INFO_LENGTH_MISMATCH )
		  {
			 ExFreePoolWithTag(pBuf, 0);
			 buflen *= 2;
			 continue; //继续下一次循环
		  }
		  else
		  {
			  dprintf("查询失败,返回!\n");
			  return ResultProcess;//未知原因错误,直接返回
		  }
	  }
	  else
	  {
		  //dprintf("查询成功,准备开始枚举!\n");
		  break;//成功了,跳出循环
	  }
	  
  }
  //dprintf("ZwQuerySystemInformation成功,现在来遍历缓冲区\n");
  if ( pBuf )
  {
    HandleCount = *(DWORD*)pBuf;
    cnt = 0;
    if ( HandleCount )
    {
      pSysHandleInfo = (PSYSTEM_HANDLE_INFORMATION)((char *)pBuf + 4);
      do
      {
        if ( pSysHandleInfo->ObjectTypeNumber == ObjTypeIndex )             // 21=OB_TYPE_PORT
        {
		  InitializeObjectAttributes(&ObjAttribute,0,OBJ_KERNEL_HANDLE,NULL,NULL);
          ClientId.UniqueProcess = (HANDLE)pSysHandleInfo->ProcessId;
          ClientId.UniqueThread = 0;
          if (NT_SUCCESS(ZwOpenProcess(&hSourceProcess, 0x40u, &ObjAttribute, &ClientId)))
          {
            if ( NT_SUCCESS(ZwDuplicateObject(
                   hSourceProcess,
                   (HANDLE)pSysHandleInfo->Handle,
                   (HANDLE)0xFFFFFFFF,
                   &HandleNew,
                   0,
                   0,
                   DUPLICATE_SAME_ACCESS)))
            {
              if (NT_SUCCESS( ZwQueryObject(HandleNew,
				  ObjectNameInfo,
				  &ObjectInformation,
				  0x100u,
				  0)))
              {
				//下面这句是自己改的
				namebuffer=(PUNICODE_STRING)ObjectInformation;
				if ( namebuffer->Buffer)
                {
					//dprintf("%ws\n",namebuffer->Buffer);
					if ( !wcsncmp(wsObjName, namebuffer->Buffer, wcslen(wsObjName)) )
					{
						ProcessId =(HANDLE)(pSysHandleInfo->ProcessId);     // 偏移为0的地方即PID
						bFound=TRUE; //找到后，设置退出标志
					}
                }
              }
              ZwClose(HandleNew);
            }
            ZwClose(hSourceProcess);
          }
        }
		if (bFound) break;//这一句也是后来加的
        ++cnt;
        pSysHandleInfo ++;
      }
      while ( cnt < HandleCount);
    }
    ExFreePoolWithTag(pBuf, 0);
  }
  status = PsLookupProcessByProcessId(ProcessId,&ResultProcess);
  if (NT_SUCCESS(status))
  {
	  ObDereferenceObject(ResultProcess);
  }
  return ResultProcess;
}

void FixupCallbackPointers(USERHOOK *pData)
{
	LPDWORD offsetPointers;
	ULONG_PTR fixup;
	offsetPointers = (LPDWORD)((BYTE*)pData + pData->offCbkPtrs);
	for(fixup=0;fixup < pData->dwFixupsCount;fixup++)
	{
		*(ULONG_PTR*)((BYTE*)pData + *offsetPointers) += (ULONG_PTR)pData;
		offsetPointers++;
	}
}

NTSTATUS
Fake_KeUserModeCallback(
	ULONG ApiNumber,
	PVOID InputBuffer,
	ULONG InputLength,
	PVOID *OutputBuffer,
	PULONG OutputLength
	)
{
	BYTE Buffer[1024]={0};
	USERHOOK *pLoadDllInfo;
	NTSTATUS status ;
	
	InterlockedIncrement(&g_Cnt);
	//dprintf("[AntiDllInject] %s ApiNumber = %d CallCnt++\n",PsGetProcessImageFileName(PsGetCurrentProcess()),ApiNumber);
	if (ApiNumber == g_IndexOfCallBack && InputBuffer != NULL)
	{
		memcpy(Buffer,InputBuffer,InputLength);
		pLoadDllInfo = (USERHOOK*)Buffer;
		if (!pLoadDllInfo->bFixed)
		{
			FixupCallbackPointers(pLoadDllInfo);
		}
		
		dprintf("[AntiDllInject] %s 正在加载 %wZ\n",PsGetProcessImageFileName(PsGetCurrentProcess()),&pLoadDllInfo->lpDLLPath);
	}
	status = Original_KeUserModeCallBack(ApiNumber,InputBuffer,InputLength,OutputBuffer,OutputLength);
	
	if (g_bEnableShow)
	{
		dprintf("[AntiDllInject] %s ApiNumber = %d  CallCnt--\n",PsGetProcessImageFileName(PsGetCurrentProcess()),ApiNumber);
	}
	
	InterlockedDecrement(&g_Cnt);
	return status;
}