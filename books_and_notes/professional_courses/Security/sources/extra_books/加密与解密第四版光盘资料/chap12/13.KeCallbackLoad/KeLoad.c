/*-----------------------------------------------------------------------
第12章  注入技术
《加密与解密（第四版）》
(c)  看雪学院 www.kanxue.com 2000-2018
-----------------------------------------------------------------------*/

/*

  KeLoad.C

  Author: achillis
  Last Updated: 2016-03-23

  This framework is generated by EasySYS 0.3.0
  This template file is copying from QuickSYS 0.3.0 written by Chunhua Liu

*/

#include "dbghelp.h"
#include "KeLoad.h"
#include "AcCommon.h"
#include "ntifs.h"
#include <ntimage.h>

// Device driver routine declarations.
//
typedef struct _DEVICE_EXTENSION
{
    ULONG  StateVariable;
	
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define IOCTL_CALLBCK 0x224000

//Vista之前使用如下结构
typedef struct _USERHOOK_OLD
{
	/*off=0x00*/DWORD      dwBufferSize;		//本结构及附加数据的总大小
	/*off=0x04*/DWORD      dwAdditionalData; //指本结构之后有多少附加数据，一般是路径,按字长对齐
	/*off=0x08*/ULONG_PTR  dwFixupsCount;	//有几个地址需要修正
	/*off=0x0C*/LPVOID     pbFree;			//不明
	/*off=0x10*/ULONG_PTR  offCbkPtrs;		//指向要修正的偏移地址存放的位置
	/*off=0x14*/ULONG_PTR  bFixed;			//修正标志
	/*off=0x18*/UNICODE_STRING lpDLLPath;	//Dll路径,Buffer可能需要修正
	/*off=0x20*/ULONG      lpfnInitOffset;	//InitFun相对于模块基址的偏移
	/*off=0x24*/DWORD      offCbk[1];		//需要修正的数据在本结构中的偏移
} USERHOOK_OLD;

//Vista之后使用新的结构
typedef struct _USERHOOK_NEW
{
	/*off=0x00_00*/DWORD      dwBufferSize;		//本结构及附加数据的总大小
	/*off=0x04_04*/DWORD      dwAdditionalData; //指本结构之后有多少附加数据，一般是路径,按字长对齐
	/*off=0x08_08*/ULONG_PTR  dwFixupsCount;	//有几个地址需要修正
	/*off=0x0C_10*/LPVOID     pbFree;			//不明
	/*off=0x10_18*/ULONG_PTR  offCbkPtrs;		//指向要修正的偏移地址存放的位置
	/*off=0x14_20*/ULONG_PTR  bFixed;			//修正标志
	/*off=0x18_28*/UNICODE_STRING lpDLLPath;	//Dll路径,Buffer可能需要修正
	/*off=0x20_38*/UNICODE_STRING lpInitFunctionName;		//HookProc的名称,根据其Buffer是否为NULL判断这里是函数名称还是偏移
	/*off=0x28_48*/DWORD      offCbk[2];		//需要修正的数据在本结构中的偏移
} USERHOOK_NEW;

typedef struct _LDR_LOADDLL_PACKET 
{
	//LdrLoadDll地址
	ULONG_PTR fnLdrLoadDll;
	//参数
	PWSTR SearchPath;
	PULONG LoadFlags;
	PUNICODE_STRING ModuleName;
	PVOID DllHandle;
}LDR_LOADDLL_PACKET,*PLDR_LOADDLL_PACKET;

typedef struct _CLIENT_LOAD_DATA 
{
	PVOID pShellCode;
	ULONG LoadFlags;
	UNICODE_STRING usDllPath;
	PVOID DllHandle;
	WCHAR wDllPath[260];
	BYTE  ShellCode[0x400];
}CLIENT_LOAD_DATA;

typedef struct _INJECT_DATA 
{
	PVOID pShellCode;//指向ShellCode
	PWSTR PathToFile;//LdrLoadDll的第一个参数
	ULONG DllCharacteristics; //第二个参数
	PUNICODE_STRING pDllPath;//第三个参数,PUNICODE_STRING DllPath
	PVOID ModuleHandle; //第四个参数,Dll句柄
	ULONG_PTR AddrOfLdrLoadDll;//LdrLoadDll地址
	UNICODE_STRING usDllPath;//Dll路径
	WCHAR wDllPath[260];//Dll路径，也就是usDllPath中的Buffer
	BYTE  ShellCode[0x100];
}INJECT_DATA;

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	);

NTSTATUS
KeloadDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
KeloadDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
KeloadDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

VOID
KeloadUnload(
	IN PDRIVER_OBJECT		DriverObject
	);

typedef NTSTATUS
(NTAPI *PFN_NtTestAlert)(
	VOID
    );

NTSTATUS
DetourNtTestAlert(
	VOID
    );

typedef NTSTATUS
(NTAPI *PFN_LdrLoadDll)(
	IN PWSTR SearchPath ,//如下所示
	IN PULONG LoadFlags , //对于直接的LoadLibrary，这个标志的内容为0
	IN PUNICODE_STRING Name,//LoadLibrary传入的字符串的UNICODE_STRING形式，若带有路径这里也有路径
	OUT PVOID *BaseAddress
	);

typedef NTSTATUS
(NTAPI *PFN_NtCallbackReturn)(
	IN PVOID OutputBuffer,
	IN ULONG OutputLength,
	IN NTSTATUS Status
	);

NTSTATUS
CallBackInjectDllRelyOnUser32(
	WCHAR *wDllPathToInject
	);

NTSTATUS
CallBackInjectDllManual(
	WCHAR *wDllPathToInject
	);

NTSTATUS
KernelLoadLibrary(
						WCHAR *wDllPathToInject
	);

NTSTATUS MyClientLoadLibrary(USERHOOK_OLD *pData);
void CallBackStub(void);
VOID InitCallBackIndex();
BOOL InitGlobalVars();
VOID ShellCodeFun(VOID);
BOOL IsTagetProcess(PEPROCESS Eprocess);
VOID InjectDll();
VOID ShowCurThreadStatus();
VOID RestoreThreadStatusForWin10();
VOID PrepareThreadStatusForWin10();

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, KeloadDispatchCreate)
#pragma alloc_text(PAGE, KeloadDispatchClose)
#pragma alloc_text(PAGE, KeloadDispatchDeviceControl)
#pragma alloc_text(PAGE, KeloadUnload)
#endif // ALLOC_PRAGMA


ULONG g_ClientLoadLibraryIndex = 0x42;
BOOL  g_bLoadingDll = FALSE;
BOOL  g_bDllLoaded = FALSE ;
WCHAR g_DllPathToInject[260] = L"C:\\MsgDll.dll";
WCHAR g_DllName[260] = L"MsgDll.dll";
char  g_szProcessToInject[260] = "notepad.exe";
char  g_ServiceName[32]="NtTestAlert";
ULONG g_IndexOfNtTestAlert = 0 ;
BOOL  g_IsLoadingDll = FALSE ;
PFN_NtTestAlert g_OriginalNtTestAlert = NULL;
WCHAR g_wsDllSearchPath[300]={0};
BYTE  g_Win10ThreadApcIndex = 0 ;
DWORD g_Win10ThreadApcDisabled = 0;

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	)
{
	NTSTATUS			status = STATUS_SUCCESS;    
    UNICODE_STRING		ntDeviceName;
	UNICODE_STRING		dosDeviceName;
    PDEVICE_EXTENSION	deviceExtension;
	PDEVICE_OBJECT		deviceObject = NULL;
	BOOLEAN				fSymbolicLink = FALSE;
	
    //
    // A real driver would:
    //
    //     1. Report it's resources (IoReportResourceUsage)
    //
    //     2. Attempt to locate the device(s) it supports
	
    //
    // OK, we've claimed our resources & found our h/w, so create
    // a device and initialize stuff...
    //
	
    RtlInitUnicodeString(&ntDeviceName, KELOAD_DEVICE_NAME_W);
	
    //
    // Create an EXCLUSIVE device, i.e. only 1 thread at a time can send
    // i/o requests.
    //
	
    status = IoCreateDevice(
		DriverObject,
		sizeof(DEVICE_EXTENSION), // DeviceExtensionSize
		&ntDeviceName, // DeviceName
		FILE_DEVICE_KELOAD, // DeviceType
		0, // DeviceCharacteristics
		TRUE, // Exclusive
		&deviceObject // [OUT]
		);
	
    if (!NT_SUCCESS(status))
	{
		dprintf("[CallBack] IoCreateDevice = 0x%x\n", status);
		goto __failed;
	}
	
	deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;
	
	//
	// Set up synchronization objects, state info,, etc.
	//
	
    //
    // Create a symbolic link that Win32 apps can specify to gain access
    // to this driver/device
    //
	
    RtlInitUnicodeString(&dosDeviceName, KELOAD_DOS_DEVICE_NAME_W);
	dprintf("[KeLoad] DeviceName : %wZ\n",&ntDeviceName);
	
    status = IoCreateSymbolicLink(&dosDeviceName, &ntDeviceName);
	
    if (!NT_SUCCESS(status))
    {
        dprintf("[CallBack] IoCreateSymbolicLink = 0x%x\n", status);
		goto __failed;
    }
	
	fSymbolicLink = TRUE;
	
    //
    // Create dispatch points for device control, create, close.
    //
	
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = KeloadDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = KeloadDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = KeloadDispatchDeviceControl;
    DriverObject->DriverUnload                         = KeloadUnload;
	
	if (InitGlobalVars() == FALSE)
    {
		DbgPrint("[DriverEntry] InitGlobalVars Failed!\n");
		goto __failed;
    }
	
	g_OriginalNtTestAlert = (PFN_NtTestAlert)HookSSDTServiceByIndex(g_IndexOfNtTestAlert,(ULONG)DetourNtTestAlert);
	if (g_OriginalNtTestAlert == 0)
	{
		DbgPrint("[DriverEntry] HookSSDTServiceByIndex Failed!\n");
		goto __failed;
	}
	dprintf("HOOK %s OK! FunAddr = 0x%X\n",g_ServiceName,g_OriginalNtTestAlert);
	

	DbgPrint("[KeLoad] Successfully Loaded!\n");
    if (NT_SUCCESS(status))
		return status;
	
__failed:
	
	if (fSymbolicLink)
		IoDeleteSymbolicLink(&dosDeviceName);
	
	if (deviceObject)
		IoDeleteDevice(deviceObject);
	
	return status;
}

NTSTATUS
KeloadDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[KeLoad] IRP_MJ_CREATE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
KeloadDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[KeLoad] IRP_MJ_CLOSE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
KeloadDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS			status = STATUS_SUCCESS;
    PIO_STACK_LOCATION	irpStack;
    PDEVICE_EXTENSION	deviceExtension;
    PVOID				ioBuf;
    ULONG				inBufLength, outBufLength;
	ULONG				ioControlCode;
	
	dprintf("[KeLoad] IRP_MJ_DEVICE_CONTROL\n");

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
	
    Irp->IoStatus.Information = 0;
	
    //
    // Get the pointer to the input/output buffer and it's length
    //
	
    ioBuf = Irp->AssociatedIrp.SystemBuffer;
    inBufLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outBufLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
	
    switch (ioControlCode)
    {
	case IOCTL_CALLBCK:
		{
			dprintf("[KeLoad] 准备注入Dll.\n");
			InjectDll();
            break;
		}
		
    default:
        status = STATUS_INVALID_PARAMETER;
		
        dprintf("[CallBack] unknown IRP_MJ_DEVICE_CONTROL = 0x%x (%04x,%04x)\n",
			ioControlCode, DEVICE_TYPE_FROM_CTL_CODE(ioControlCode),
			IoGetFunctionCodeFromCtlCode(ioControlCode));
		
        break;
	}
	
    //
    // DON'T get cute and try to use the status field of
    // the irp in the return status.  That IRP IS GONE as
    // soon as you call IoCompleteRequest.
    //
	
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
	
    //
    // We never have pending operation so always return the status code.
    //
	
    return status;
}

VOID
KeloadUnload(
	IN PDRIVER_OBJECT		DriverObject
	)
{
	UNICODE_STRING dosDeviceName;
	
	//
    // Free any resources
    //
	UnhookSSDTServiceByIndex(g_IndexOfNtTestAlert,(ULONG)g_OriginalNtTestAlert);
	
    //
    // Delete the symbolic link
    //
	
    RtlInitUnicodeString(&dosDeviceName, KELOAD_DOS_DEVICE_NAME_W);
	
    IoDeleteSymbolicLink(&dosDeviceName);
	
    //
    // Delete the device object
    //
	
    IoDeleteDevice(DriverObject->DeviceObject);
	
	
    DbgPrint("[KeLoad] Unloaded\n");
}

BOOL InitGlobalVars()
{
	//通过查找ntdll的导出表，获取NtTestAlert的服务索引
	NTSTATUS status;
	MAP_IMAGE_INFO NtdllInfo = {0};
	ULONG_PTR MapedNtdllBase=0;
	
	char szNtdllPath[MAX_PATH] = "\\SystemRoot\\system32\\ntdll.dll";
	status = MapImageFile(szNtdllPath,&NtdllInfo);
	
	if (!NT_SUCCESS(status))
	{
		dprintf("[GetServiceIndex] Map Ntdll.dll Failed!\n");
		return FALSE;
	}
	
	MapedNtdllBase = (ULONG_PTR)NtdllInfo.MappedBase;
	g_IndexOfNtTestAlert = GetServiceIndexByName(MapedNtdllBase,g_ServiceName);
	UnMapImageFile(&NtdllInfo);
	

	if (g_IndexOfNtTestAlert==0)
	{
		dprintf("[InitGlobalVars] Get ServiceIndex of %s Failed!\n",g_ServiceName);
		return FALSE;
	}

	InitCallBackIndex();
	
	//准备SearchPath，先复制系统目录
	wcscpy(g_wsDllSearchPath,(WCHAR*)(KI_USER_SHARED_DATA+0x30));//C:\Windows
	wcscat(g_wsDllSearchPath,L";");
	wcscat(g_wsDllSearchPath,(WCHAR*)(KI_USER_SHARED_DATA+0x30));
	wcscat(g_wsDllSearchPath,L"\\System32");
	dprintf("[KeLoad] SearchPath : %ws\n",g_wsDllSearchPath);

	return TRUE;
}

VOID InitCallBackIndex()
{
	DWORD dwBuildNum =0 ;
	//初始化
	PsGetVersion(NULL,NULL,&dwBuildNum,NULL);
	switch(dwBuildNum)
	{
	case 2600:
	case 3790:
	case 6000:
	case 6001:
	case 6002:
		g_ClientLoadLibraryIndex = 0x42 ;
		break;
	case 7600:
	case 7601:
		g_ClientLoadLibraryIndex = 0x41 ;
		break;
	case 9200:
		g_ClientLoadLibraryIndex = 0x47 ;
		break;
	case 10240:
		g_ClientLoadLibraryIndex = 0x4A ;
		break;
	default:
		break;
	}
}



NTSTATUS
DetourNtTestAlert(
    VOID
    )
{
	if (g_IsLoadingDll)
	{
		dprintf("[KeLoad] 正在处理Dll加载，本次调用ByPass.\n");
		return g_OriginalNtTestAlert();
	}

	if (IsTagetProcess(PsGetCurrentProcess()))
	{
		InjectDll();
	}

	return g_OriginalNtTestAlert();

}

VOID InjectDll()
{
	NTSTATUS OriginalStatus = STATUS_SUCCESS ;
	NTSTATUS status  = STATUS_SUCCESS ;
	PEPROCESS CurProcess = PsGetCurrentProcess();
	ULONG_PTR TargetModuleBase = 0 ;
	PPEB Peb = PsGetProcessPeb(CurProcess);
	DWORD dwBuildNum = 0;
	
	dprintf("[KeLoad] In InjectDll.\n");
	
	//先判断有没有加载目标模块
	dprintf("[KeLoad] 判断是否已经加载了目标模块.\n");
	TargetModuleBase = KeGetUserModuleHandle(g_DllName);
	if (TargetModuleBase == 0)
	{
		PsGetVersion(NULL,NULL,&dwBuildNum,NULL);
		if (dwBuildNum >= 10240)
		{
			//Win10系统中KeUserModeCallback检查更严格,必须使ApcIndex = 0 ,KernelApcDiable = 0 , 否则将出现APC_INDEX_MISPATCH错误
			PrepareThreadStatusForWin10();
		}
		dprintf("[KeLoad] 尚未加载目标Dll,现在加载!\n");
		ShowCurThreadStatus();
		//判断KernelCallBackTable有没有初始化
		if (Peb->KernelCallbackTable != NULL)
		{
			g_IsLoadingDll = TRUE ;
			//这里使用了两种方法来加载Dll
			//1.直接回调user32!__ClientLoadLibrary
			dprintf("[KeLoad] KernelCallBackTable已经初始化,调用_ClientLoadLibrary加载!\n");
			status = CallBackInjectDllRelyOnUser32(g_DllPathToInject); //在有user32时测试通过
			//2.不依赖user32!__ClientLoadLibrary，回调自己的ShellCode
			//status = CallBackInjectDllManual(g_DllPathToInject); //在有user32时测试通过,无user32蓝屏
			//3.方法同上，但使用的ShellCode更有通用性
			//status = KernelLoadLibrary(g_DllPathToInject);//在有user32时测试通过,无user32蓝屏
			g_IsLoadingDll  = FALSE ;
		}
		else
		{
			g_IsLoadingDll = TRUE ;
			dprintf("[KeLoad] KernelCallBackTable未初始化,自行准备Shellcode!\n");
			status = CallBackInjectDllManual(g_DllPathToInject); //XP下蓝屏
			g_IsLoadingDll  = FALSE ;
		}

		if (dwBuildNum >= 10240)
		{
			RestoreThreadStatusForWin10();
		}
	}
	else
	{
		dprintf("[KeLoad] 目标Dll已经加载,不再处理!\n");
	}
}

VOID ShowCurThreadStatus()
{
	PETHREAD CurThread = PsGetCurrentThread();
	BYTE ApcIndex = *((BYTE*)CurThread + 0x16A) ;
	DWORD ApcDiabled = *(DWORD*)((BYTE*)CurThread + 0x13C) ;

	dprintf("[KeLoad] ApcIndex = 0x%X  ApcDisabled = 0x%X\n",ApcIndex,ApcDiabled);
}


VOID PrepareThreadStatusForWin10()
{
	PETHREAD CurThread = PsGetCurrentThread();
	g_Win10ThreadApcIndex = *((BYTE*)CurThread + 0x16A) ;
	g_Win10ThreadApcDisabled = *(DWORD*)((BYTE*)CurThread + 0x13C) ;

	*((BYTE*)CurThread + 0x16A) = 0 ;
	*(DWORD*)((BYTE*)CurThread + 0x13C)  = 0 ;
}

VOID RestoreThreadStatusForWin10()
{
	PETHREAD CurThread = PsGetCurrentThread();
	
	*((BYTE*)CurThread + 0x16A) = g_Win10ThreadApcIndex ;
	*(DWORD*)((BYTE*)CurThread + 0x13C)  = g_Win10ThreadApcDisabled ;
}
//检查目标进程是不是notepad.exe
BOOL IsTagetProcess(PEPROCESS Eprocess)
{
	char *szProcname = (char*)PsGetProcessImageFileName(Eprocess);
	if (_stricmp(szProcname,g_szProcessToInject) == 0)
	{
		return TRUE;
	}
	return FALSE;
	
}


//必须保证user32.dll已经加载,测试通过
NTSTATUS
CallBackInjectDllRelyOnUser32(
	WCHAR *wDllPathToInject
	)
{
	NTSTATUS status ;
	BYTE TempBuffer[1024]={0};
	USERHOOK_OLD *pOldInfo = NULL;
	USERHOOK_NEW *pNewInfo = NULL;
	ULONG uBufSize = 0 ;
	UNICODE_STRING usDllPath ;
	ULONG OutputBufSize = 0 ;
	DWORD dwBuildNum =0 ;
	PVOID *DllHandle;
	PVOID InputBuffer = NULL ;
	ULONG InputLength = 0 ;

	//初始化Buffer
	RtlInitUnicodeString(&usDllPath,wDllPathToInject);
	RtlZeroMemory(TempBuffer,1024);

	PsGetVersion(NULL,NULL,&dwBuildNum,NULL);
	if (dwBuildNum < 6000)
	{
		//使用旧数据结构
		pOldInfo = (USERHOOK_OLD*)TempBuffer;
		uBufSize  = (wcslen(wDllPathToInject) + 1)*sizeof(WCHAR);
		pOldInfo->dwAdditionalData = ALIGN_UP(uBufSize,ULONG_PTR);
		pOldInfo->dwFixupsCount = 1 ;
		pOldInfo->offCbkPtrs = FIELD_OFFSET(USERHOOK_OLD,offCbk);
		pOldInfo->bFixed = FALSE ;
		pOldInfo->dwBufferSize = sizeof(USERHOOK_OLD) + pOldInfo->dwAdditionalData;
		wcscpy((WCHAR*)((BYTE*)pOldInfo + sizeof(USERHOOK_OLD)),wDllPathToInject);
		pOldInfo->lpDLLPath.Length = usDllPath.Length;
		pOldInfo->lpDLLPath.MaximumLength = usDllPath.MaximumLength;
		pOldInfo->lpDLLPath.Buffer = (PWSTR)sizeof(USERHOOK_OLD);
		pOldInfo->offCbk[0] = FIELD_OFFSET(USERHOOK_OLD,lpDLLPath.Buffer);

		//设置In参数
		InputBuffer = pOldInfo;
		InputLength = pOldInfo->dwBufferSize ;
	}
	else
	{
		pNewInfo = (USERHOOK_NEW*)TempBuffer;
		uBufSize  = (wcslen(wDllPathToInject) + 1)*sizeof(WCHAR);
		pNewInfo->dwAdditionalData = ALIGN_UP(uBufSize,ULONG_PTR);
		pNewInfo->dwFixupsCount = 1 ;
		pNewInfo->offCbkPtrs = FIELD_OFFSET(USERHOOK_NEW,offCbk);
		pNewInfo->bFixed = FALSE ;
		pNewInfo->dwBufferSize = sizeof(USERHOOK_NEW) + pNewInfo->dwAdditionalData;
		wcscpy((WCHAR*)((BYTE*)pNewInfo + sizeof(USERHOOK_NEW)),wDllPathToInject);
		pNewInfo->lpDLLPath.Length = usDllPath.Length;
		pNewInfo->lpDLLPath.MaximumLength = usDllPath.MaximumLength;
		pNewInfo->lpDLLPath.Buffer = (PWSTR)sizeof(USERHOOK_NEW);
		pNewInfo->offCbk[0] = FIELD_OFFSET(USERHOOK_OLD,lpDLLPath.Buffer);
		
		//设置In参数
		InputBuffer = pNewInfo;
		InputLength = pNewInfo->dwBufferSize ;
	}
	
	
	dprintf("[KeLoad] 开始调用KeUserModeCallback.\n");
	status = KeUserModeCallback(
		g_ClientLoadLibraryIndex,
		InputBuffer,
		InputLength,
		(PVOID*)&DllHandle,
		&OutputBufSize
		);
	dprintf("[KeLoad] 调用KeUserModeCallback完成. status = 0x%08X\n",status);
	if (NT_SUCCESS(status))
	{
		dprintf("[KeLoad] Dll加载成功, hModule = 0x%p",*DllHandle);
	}
	return status;
}

//长度为34字节
//__declspec ( naked )
NTSTATUS
MyClientLoadLibrary(USERHOOK_OLD *pData)
{/*
	_asm
	{	
		int 3
		push ebp
		mov ebp,esp
		sub  esp,0x20
		push ebx
		push esi
		push edi
		mov  ebx,[ebp+8] //LOAD_DLL_PARAM
		//修正usDllpath
		mov eax,[ebx]_USERHOOK_OLD.offCbkPtrs
		mov eax,[ebx + eax]	;取offset
		add [ebx+eax],eax
		lea eax,[ebp-4] ;DllBase
		push eax
		lea eax,[ebx]_USERHOOK_OLD.lpDLLPath
		push eax
		mov [ebp-8],0	;LoadFlag
		lea eax,[ebp-8] ;DllBase
		push eax
		xor eax,eax
		push eax
		call [ebx]_USERHOOK_OLD.pbFree




		//保存三个寄存器用去了0xC的栈空间
		mov ecx,dword ptr [esp+8+0xC] //ecx是InputBuffer的长度
		sub ecx,4 //减去4,即跳过前面API的地址
		mov     eax,dword ptr [esp+4+0xC]//取OldUserStack
		lea esi,[eax+4] //eax+4指向参数列表
		sub esp,ecx //开辟栈空间
		mov edi,esp //准备
		shr ecx,2 //设置要复制的长度，按DWORD复制,所以要除以4,准备复制参数
		rep movs dword ptr es:[edi],dword ptr ds:[esi] //复制参数,F3,A5
		call    dword ptr [eax] //call API
		pop edi
		pop esi
		pop ebx
		leave
		ret 4
		int     3
	}
	*/
	NTSTATUS status;
	ULONG LoadFlag = 0 ;
	PVOID ModuleBase = 0 ;
	PFN_LdrLoadDll pfnLoadDll = (PFN_LdrLoadDll)pData->pbFree ;
	PFN_NtCallbackReturn pfnCallRetn = (PFN_NtCallbackReturn)pData->dwFixupsCount ;
	ULONG *Offset = NULL ;
	//修正偏移
	if (! pData->bFixed)
	{
		//要修正的位置
		Offset = (ULONG*)((ULONG_PTR)pData + pData->offCbkPtrs );
		//修正
		*(ULONG_PTR*)((ULONG_PTR)pData + *Offset) += (ULONG_PTR)pData ;
		
	}

	//加载Dll
	status = pfnLoadDll(NULL,&LoadFlag,&pData->lpDLLPath,&ModuleBase);
	//返回
	pfnCallRetn(&ModuleBase,sizeof(PVOID),status);
	return status;

}

__declspec ( naked ) void
CallBackStub(void)
{
	_asm
	{	
		push ecx
		push esi
		push edi
		//保存三个寄存器用去了0xC的栈空间
		mov ecx,dword ptr [esp+8+0xC] //ecx是InputBuffer的长度
		sub ecx,4 //减去4,即跳过前面API的地址
		mov eax,dword ptr [esp+4+0xC]//取OldUserStack
		lea esi,[eax+4] //eax+4指向参数列表
		sub esp,ecx //开辟栈空间
		mov edi,esp //准备
		shr ecx,2 //设置要复制的长度，按DWORD复制,所以要除以4,准备复制参数
		rep movs dword ptr es:[edi],dword ptr ds:[esi] //复制参数,F3,A5
		call    dword ptr [eax] //call API
		pop edi
		pop esi
		pop ecx
		ret 8
		nop
		nop
		nop
		nop
		nop
	}
}

//该函数模拟了user32!__ClientLoadLibrary
__declspec( naked )
VOID ShellCodeFun(VOID)
{
	__asm
	{
		push ebp
		mov  ebp,esp
		sub  esp,0xC
		push ebx
		call Next
Next:
		pop ebx
		and bx,0						;低位清零，即得到基址
		lea eax,dword ptr ds:[ebx]INJECT_DATA.ModuleHandle
		push eax						;pModuleHandle
		push dword ptr ds:[ebx]INJECT_DATA.pDllPath
		lea eax,dword ptr ds:[ebx]INJECT_DATA.DllCharacteristics
		push eax						;DllCharacteristics
		push dword ptr ds:[ebx]INJECT_DATA.PathToFile
		call dword ptr ds:[ebx]INJECT_DATA.AddrOfLdrLoadDll         ;  LdrLoadDll
		mov     [ebp - 0xC], eax		;保存status
		push 0
		push 0xC
		pop  edx
		lea     ecx, [ebp - 0xC]
		call    XyCallbackReturn
		_emit 0xC9 ;leave
		ret   4
XyCallBackReturn:
		mov     eax, [esp+4]
		int		0x2B					;返回到内核中
		retn    4
		nop
		nop
		nop
		nop
		nop
	}
}

/*
; NTSTATUS
; NtCallbackReturn (
;    IN PVOID OutputBuffer OPTIONAL,
;    IN ULONG OutputLength,
;    IN NTSTATUS Status
;    )
*/
/*
NTSTATUS NTAPI
LdrLoadDll (IN PWSTR SearchPath OPTIONAL,//如下所示
IN PULONG LoadFlags OPTIONAL, //对于直接的LoadLibrary，这个标志的内容为0
IN PUNICODE_STRING Name,//LoadLibrary传入的字符串的UNICODE_STRING形式，若带有路径这里也有路径
OUT PVOID *BaseAddress);
*/
//该函数利用ntdll.LdrLoadDll加载目标模块

NTSTATUS
KernelLoadLibrary(
	WCHAR *wDllPathToLoad
	)
{
	NTSTATUS status;
	ULONG_PTR NtdllBase = 0 ;
	ULONG ApiIndex;
	PVOID KernelCallBackTable;
	PPEB Peb;
	SIZE_T buflen=0x1000,needlen=0;
	ULONG ResultLentgh;
	PVOID ResultBuffer;
	PVOID *DllHandle;
	PVOID InputBuffer = NULL ;
	ULONG InputLength = 0 ;
	ULONG OutputBufSize = 0 ;
	SIZE_T MemSize = 0x1000;
	ULONG uShellCodeSize = 0 ;
	CLIENT_LOAD_DATA *pData = NULL ;
	BYTE *pFunStart = NULL,*pFunEnd = NULL ,*pTemp = NULL;
	LDR_LOADDLL_PACKET LoadPacket;
	
	dprintf("[KernelLoadLibrary] 第二种方法...\n");
	Peb = PsGetProcessPeb(PsGetCurrentProcess());
	__try
	{
		//取CallBackTable的地址
		KernelCallBackTable = Peb->KernelCallbackTable ;//偏移为0x2C
		dprintf("[KernelLoadLibrary] KernelCallBackTable = 0x%p\n",KernelCallBackTable);
		
		//取ntdll.dll的基址
		NtdllBase = KeGetUserModuleHandle(L"ntdll.dll");
		if (NtdllBase == 0)
		{
			DbgPrint("[KernelLoadLibrary] Error, Could not get baseaddress of ntdll.\n");
			return 0;
		}

		//申请内存，准备写入shellcode和参数
		status=ZwAllocateVirtualMemory(NtCurrentProcess(),&pData,0,&buflen,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
		if (!NT_SUCCESS(status))
		{
			DbgPrint("[KernelLoadLibrary] Error, Alloc Usermode Memory Failed. status = 0x%08X\n",status);
			return 0;
		}
		dprintf("[KernelLoadLibrary] Alloced Buffer=0x%08X\n",pData);

		//开始填充pData
		//计算ShellCode的长度
		pFunStart = (BYTE*)CallBackStub;
		pTemp = pFunStart;
		
		pTemp += 0x20 ; //缩小搜索范围
		while (memcmp(pTemp,"\x90\x90\x90\x90\x90",5) != 0)
		{
			pTemp++;
		}
		
		//pTemp指向结束位置
		uShellCodeSize = pTemp - pFunStart;
		dprintf("[KernelLoadLibrary] ShellCode Len = 0x%X\n",uShellCodeSize);
		//保存ShellCode
		memcpy(pData->ShellCode,pFunStart,uShellCodeSize);
		
		pData->pShellCode  = pData->ShellCode;
		//下面开始填充LdrLoadDll的参数
		//初始化DllCharacteristics
		pData->LoadFlags = 0 ;
		//初始化UNICODE_STRING
		wcscpy(pData->wDllPath,wDllPathToLoad);
		RtlInitUnicodeString(&pData->usDllPath,pData->wDllPath);
		
		RtlZeroMemory(&LoadPacket,sizeof(LDR_LOADDLL_PACKET));
		LoadPacket.fnLdrLoadDll = KeGetProcAddress(NtdllBase,"LdrLoadDll");
		LoadPacket.SearchPath = NULL ; //初始化SearchPath为NULL
		LoadPacket.LoadFlags  = &pData->LoadFlags ;
		LoadPacket.ModuleName = &pData->usDllPath;
		LoadPacket.DllHandle  = &pData->DllHandle ;

		dprintf("[KernelLoadLibrary] LdrLoadDll = 0x%p\n",LoadPacket.fnLdrLoadDll);
		
		//设置In参数
		InputBuffer = &LoadPacket;
		InputLength = sizeof(LDR_LOADDLL_PACKET)  ;
		dprintf("[KernelLoadLibrary] InputBuffer = 0x%p InputLength = 0x%X\n",InputBuffer,InputLength);
		//填充完毕
		//准备参数,KernelCallBackTable可以为0
		ApiIndex = ((ULONG_PTR)pData - (ULONG_PTR)KernelCallBackTable) / sizeof(ULONG_PTR);
		dprintf("[KernelLoadLibrary] 开始调用KeUserModeCallback.\n");
		status = KeUserModeCallback(ApiIndex,InputBuffer,InputLength,(PVOID*)&DllHandle,&OutputBufSize);
		dprintf("[KernelLoadLibrary] 调用KeUserModeCallback完成. status = 0x%08X\n",status);
		if (NT_SUCCESS(status))
		{
			dprintf("[KernelLoadLibrary] Dll加载成功, hModule = 0x%p",pData->DllHandle);
		}

		ZwFreeVirtualMemory(NtCurrentProcess(),&pData,&buflen,MEM_RELEASE);
	}
	__except(1)
	{
		DbgPrint("[KernelLoadLibrary] Unknown Error occured.\n");
		return 0;
	}
	return status;
}

//函数功能测试通过,XP/Win7均正常
NTSTATUS
CallBackInjectDllManual(
	WCHAR *wDllPathToInject
	)
{
	NTSTATUS status;
	ULONG_PTR NtdllBase = 0 ;
	ULONG ApiIndex;
	PVOID KernelCallBackTable;
	PPEB Peb;
	SIZE_T buflen=0x1000,needlen=0;
	ULONG ResultLentgh;
	PVOID ResultBuffer;
	PVOID *DllHandle;
	PVOID InputBuffer = NULL ;
	ULONG InputLength = 0 ;
	ULONG OutputBufSize = 0 ;
	INJECT_DATA *pData = NULL;
	SIZE_T MemSize = 0x1000;
	ULONG uShellCodeSize = 0 ;
	BYTE *pFunStart = NULL,*pFunEnd = NULL ,*pTemp = NULL;

	Peb = PsGetProcessPeb(PsGetCurrentProcess());
	__try
	{
		//取CallBackTable的地址
		KernelCallBackTable = Peb->KernelCallbackTable ;//偏移为0x2C
		dprintf("[CallBackInjectDllManual] KernelCallBackTable = 0x%p\n",KernelCallBackTable);
		
		//取ntdll.dll的基址
		NtdllBase = KeGetUserModuleHandle(L"ntdll.dll");
		if (NtdllBase == 0)
		{
			DbgPrint("[CallBackInjectDllManual] Error, Could not get baseaddress of ntdll.\n");
			return 0;
		}

		//申请内存，准备写入shellcode和参数
		status=ZwAllocateVirtualMemory(NtCurrentProcess(),&pData,0,&buflen,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
		if (!NT_SUCCESS(status))
		{
			DbgPrint("[CallBackInjectDllManual] Error, Alloc Usermode Memory Failed. status = 0x%08X\n",status);
			return 0;
		}
		dprintf("[CallBackInjectDllManual] Alloced Buffer=0x%08X\n",pData);

		//开始填充缓冲区
		//计算ShellCode的长度
		pFunStart = (BYTE*)ShellCodeFun;
		pTemp = pFunStart;
		
		pTemp += 0x20 ; //缩小搜索范围
		while (memcmp(pTemp,"\x90\x90\x90\x90\x90",5) != 0)
		{
			pTemp++;
		}
		
		//pTemp指向结束位置
		uShellCodeSize = pTemp - pFunStart;
		dprintf("[CallBackInjectDllManual] ShellCode Len = 0x%X\n",uShellCodeSize);
		//保存ShellCode
		memcpy(pData->ShellCode,pFunStart,uShellCodeSize);
		
		pData->pShellCode  = pData->ShellCode;
		//下面开始填充LdrLoadDll的参数
		//初始化PathToFile为NULL
		pData->PathToFile = NULL;
		//初始化DllCharacteristics
		pData->DllCharacteristics = 0 ;
		//初始化UNICODE_STRING
		wcscpy(pData->wDllPath,wDllPathToInject);
		RtlInitUnicodeString(&pData->usDllPath,pData->wDllPath);
		
		//设置参数
		pData->pDllPath = &pData->usDllPath;
		pData->AddrOfLdrLoadDll = KeGetProcAddress(NtdllBase,"LdrLoadDll");
		dprintf("[CallBackInjectDllManual] LdrLoadDll = 0x%p\n",pData->AddrOfLdrLoadDll);
		
		//准备参数,这里只需要回调Shellcode就可以了，参数放在申请的内存中了，不需要InputBuffer
		ApiIndex = ((ULONG_PTR)pData - (ULONG_PTR)KernelCallBackTable) / sizeof(ULONG_PTR);
		dprintf("[CallBackInjectDllManual] 开始调用KeUserModeCallback.\n");
		status = KeUserModeCallback(ApiIndex,NULL,0,(PVOID*)&DllHandle,&OutputBufSize);
		dprintf("[CallBackInjectDllManual] 调用KeUserModeCallback完成. status = 0x%p\n",status);
		if (NT_SUCCESS(status))
		{
			dprintf("[CallBackInjectDllManual] Dll加载成功, hModule = 0x%p\n",pData->ModuleHandle);
		}

		ZwFreeVirtualMemory(NtCurrentProcess(),&pData,&buflen,MEM_RELEASE);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint("[KernelLoadLibrary] Unknown Error occured.\n");
		return 0;
	}
	return status;
}