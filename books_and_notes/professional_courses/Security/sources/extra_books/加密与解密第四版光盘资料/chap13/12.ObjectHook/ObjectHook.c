/*-----------------------------------------------------------------------
第13章  Hook技术
《加密与解密（第四版）》
(c)  看雪学院 www.kanxue.com 2000-2018
-----------------------------------------------------------------------*/


/*

  ObjectHook.C

  Author: achillis
  Last Updated: 2006-03-23

  This framework is generated by EasySYS 0.3.0
  This template file is copying from QuickSYS 0.3.0 written by Chunhua Liu

*/

#include "dbghelp.h"
#include "ObjectHook.h"
#include "ntifs.h"
#include "myKernel.h"

typedef struct _DEVICE_EXTENSION
{
    ULONG  StateVariable;
	
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Device driver routine declarations.
//

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	);

NTSTATUS
ObjectHookDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
ObjectHookDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
ObjectHookDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

VOID
ObjectHookUnload(
	IN PDRIVER_OBJECT		DriverObject
	);

typedef NTSTATUS
(*PIOPPARSEDEVICE)(
				   IN PVOID ParseObject,
				   IN PVOID ObjectType,
				   IN PACCESS_STATE AccessState,
				   IN KPROCESSOR_MODE AccessMode,
				   IN ULONG Attributes,
				   IN OUT PUNICODE_STRING CompleteName,
				   IN OUT PUNICODE_STRING RemainingName,
				   IN OUT PVOID Context OPTIONAL,
				   IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
				   OUT PVOID *Object
				   );

NTSTATUS
MyIopParseDevice(
				 IN PVOID ParseObject,
				 IN PVOID ObjectType,
				 IN PACCESS_STATE AccessState,
				 IN KPROCESSOR_MODE AccessMode,
				 IN ULONG Attributes,
				 IN OUT PUNICODE_STRING CompleteName,
				 IN OUT PUNICODE_STRING RemainingName,
				 IN OUT PVOID Context OPTIONAL,
				 IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
				 OUT PVOID *Object
				 );

NTSTATUS InstallDeviceObjectHook(PDEVICE_OBJECT  myDeviceObject);
NTSTATUS UnInstallDeviceObjectHook(PDEVICE_OBJECT  myDeviceObject);
NTSTATUS IsUnicodeStringValid(PUNICODE_STRING String);
VOID InitGlobalVars();

PIOPPARSEDEVICE  OriginalIopPaseDevice=NULL;
PDEVICE_OBJECT g_myCDO=NULL;
ULONG g_MyRoutineCallCnt=0;
WCHAR g_wFileNameToRedirect[260]=L"\\Windows\\System32\\calc.exe";
WCHAR g_wFileNameDestination[260]=L"\\Windows\\System32\\cmd.exe";
WCHAR g_wFileFullPathDestination[260]=L"\\Device\\HarddiskVolume1\\Windows\\System32\\cmd.exe";
UNICODE_STRING g_usFileNameToRedirect;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, ObjectHookDispatchCreate)
#pragma alloc_text(PAGE, ObjectHookDispatchClose)
#pragma alloc_text(PAGE, ObjectHookDispatchDeviceControl)
#pragma alloc_text(PAGE, ObjectHookUnload)
#endif // ALLOC_PRAGMA

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	)
{
	NTSTATUS			status = STATUS_SUCCESS;    
    UNICODE_STRING		ntDeviceName;
	UNICODE_STRING		dosDeviceName;
    PDEVICE_EXTENSION	deviceExtension;
	PDEVICE_OBJECT		deviceObject = NULL;
	BOOLEAN				fSymbolicLink = FALSE;

    dprintf("[ObjectHook] DriverEntry: %wZ\n", RegistryPath);

    //
    // A real driver would:
    //
    //     1. Report it's resources (IoReportResourceUsage)
    //
    //     2. Attempt to locate the device(s) it supports
	
    //
    // OK, we've claimed our resources & found our h/w, so create
    // a device and initialize stuff...
    //
	
    RtlInitUnicodeString(&ntDeviceName, OBJECTHOOK_DEVICE_NAME_W);
	
    //
    // Create an EXCLUSIVE device, i.e. only 1 thread at a time can send
    // i/o requests.
    //
	
    status = IoCreateDevice(
		DriverObject,
		sizeof(DEVICE_EXTENSION), // DeviceExtensionSize
		&ntDeviceName, // DeviceName
		FILE_DEVICE_OBJECTHOOK, // DeviceType
		0, // DeviceCharacteristics
		TRUE, // Exclusive
		&deviceObject // [OUT]
		);
	
    if (!NT_SUCCESS(status))
	{
		dprintf("[ObjectHook] IoCreateDevice = 0x%x\n", status);
		goto __failed;
	}
	g_myCDO=deviceObject;
	deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;
	
	//
	// Set up synchronization objects, state info,, etc.
	//
	
    //
    // Create a symbolic link that Win32 apps can specify to gain access
    // to this driver/device
    //
	
    RtlInitUnicodeString(&dosDeviceName, OBJECTHOOK_DOS_DEVICE_NAME_W);
	
    status = IoCreateSymbolicLink(&dosDeviceName, &ntDeviceName);
	
    if (!NT_SUCCESS(status))
    {
        dprintf("[FileRedirect] IoCreateSymbolicLink = 0x%x\n", status);
		goto __failed;
    }
	
	fSymbolicLink = TRUE;
	
    //
    // Create dispatch points for device control, create, close.
    //
	
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = ObjectHookDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = ObjectHookDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ObjectHookDispatchDeviceControl;
    DriverObject->DriverUnload                         = ObjectHookUnload;
	
	
    if (NT_SUCCESS(status))
	{
		InitGlobalVars();
		InstallDeviceObjectHook(g_myCDO);
		DbgPrint("[FileRedirect] Loaded Successfully!\n");
		return status;
	}
	
__failed:
	
	if (fSymbolicLink)
		IoDeleteSymbolicLink(&dosDeviceName);
	
	if (deviceObject)
		IoDeleteDevice(deviceObject);
	
	return status;
}

NTSTATUS
ObjectHookDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[ObjectHook] IRP_MJ_CREATE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
ObjectHookDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[ObjectHook] IRP_MJ_CLOSE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
ObjectHookDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	dprintf("[ObjectHook] IRP_MJ_DEVICE_CONTROL\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

VOID
ObjectHookUnload(
	IN PDRIVER_OBJECT		DriverObject
	)
{
	UNICODE_STRING dosDeviceName;
	LARGE_INTEGER Interval;
	//
    // Free any resources
    //
	//先还原HOOK
	if (OriginalIopPaseDevice)
	{
		UnInstallDeviceObjectHook(g_myCDO);
	}
	//等待计数归零
	Interval.QuadPart=-200 * 1000 * 10;//300ms

	DbgPrint("[ObjectHook] 等待调用计数归零...\n");
	while(g_MyRoutineCallCnt!=0)
	{
		KeDelayExecutionThread(0, 0, &Interval);
	}
    //
    // Delete the symbolic link
    //
	
    RtlInitUnicodeString(&dosDeviceName, OBJECTHOOK_DOS_DEVICE_NAME_W);
	
    IoDeleteSymbolicLink(&dosDeviceName);
	
    //
    // Delete the device object
    //
	
    IoDeleteDevice(DriverObject->DeviceObject);
	
    DbgPrint("[ObjectHook] Unloaded\n");
}

VOID InitGlobalVars()
{
	RtlInitUnicodeString(&g_usFileNameToRedirect,g_wFileNameToRedirect);
}

NTSTATUS InstallDeviceObjectHook(PDEVICE_OBJECT  myDeviceObject)
{
	POBJECT_HEADER ObjectHeader;
	POBJECT_TYPE DeviceObjType;
	NTSTATUS status=STATUS_UNSUCCESSFUL;
	ObjectHeader=OBJECT_TO_OBJECT_HEADER(myDeviceObject);
	DeviceObjType=ObjectHeader->Type;
	if (MmIsAddressValid(DeviceObjType))
	{
		dprintf("Get Device Type=0x%08X\n",DeviceObjType);
		if (MmIsAddressValid(DeviceObjType->TypeInfo.ParseProcedure))
		{
			OriginalIopPaseDevice=(PIOPPARSEDEVICE)InterlockedExchange((PULONG)&DeviceObjType->TypeInfo.ParseProcedure,(ULONG)MyIopParseDevice);
			dprintf("Exchanged OK! Original IopPaseDevice=0x%08X newRoutine = 0x%08X\n",OriginalIopPaseDevice,(ULONG)MyIopParseDevice);
			status=STATUS_SUCCESS;
		}
		
	}
	
	return status;
}

NTSTATUS UnInstallDeviceObjectHook(PDEVICE_OBJECT  myDeviceObject)
{
	POBJECT_HEADER ObjectHeader;
	POBJECT_TYPE DeviceObjType;
	NTSTATUS status=STATUS_UNSUCCESSFUL;
	ObjectHeader=OBJECT_TO_OBJECT_HEADER(myDeviceObject);
	DeviceObjType=ObjectHeader->Type;
	if (MmIsAddressValid(DeviceObjType))
	{
		dprintf("Get Device Type=0x%08X\n",DeviceObjType);
		if (MmIsAddressValid(DeviceObjType->TypeInfo.ParseProcedure))
		{
			InterlockedExchange((PULONG)&DeviceObjType->TypeInfo.ParseProcedure,(ULONG)OriginalIopPaseDevice);
			dprintf("UnHook IopParseDevice OK!\n");
			status=STATUS_SUCCESS;
		}
		
	}
	
	return status;
}

NTSTATUS
MyIopParseDevice(
	IN PVOID ParseObject,
	IN PVOID ObjectType,
	IN PACCESS_STATE AccessState,
	IN KPROCESSOR_MODE AccessMode,
	IN ULONG Attributes,
	IN OUT PUNICODE_STRING CompleteName,
	IN OUT PUNICODE_STRING RemainingName,
	IN OUT PVOID Context OPTIONAL,
	IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
	OUT PVOID *Object
    )
{
	NTSTATUS status;
	ULONG CurFileNameLen=0;
	UNICODE_STRING usNewCompleteName ;
	UNICODE_STRING usNewRemainingName ;

	InterlockedIncrement(&g_MyRoutineCallCnt);
	dprintf("[%s] Calling IoParseDevice...\n",PsGetProcessImageFileName(PsGetCurrentProcess()));
	usNewRemainingName = *RemainingName;
	usNewCompleteName = *CompleteName;
	if (NT_SUCCESS(IsUnicodeStringValid(RemainingName)))
	{
		if (RtlEqualUnicodeString( RemainingName,&g_usFileNameToRedirect, TRUE ))
		{
			RtlInitUnicodeString( &usNewRemainingName,g_wFileNameDestination);
			RtlInitUnicodeString( &usNewCompleteName,g_wFileFullPathDestination);
		}	
	}
	status=OriginalIopPaseDevice(ParseObject,
		ObjectType,
		AccessState,
		AccessMode,
		Attributes,
		&usNewCompleteName,
		&usNewRemainingName,
		Context,
		SecurityQos,
		Object);
	InterlockedDecrement(&g_MyRoutineCallCnt);
	return status;
}


NTSTATUS IsUnicodeStringValid(PUNICODE_STRING String)
{
	NTSTATUS Status = STATUS_SUCCESS;

    if (String != NULL) {
        if (((String->Length % 2) != 0) ||
            ((String->MaximumLength % 2) != 0) ||
            (String->Length > String->MaximumLength)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
		
        if (((String->Length != 0) ||
			(String->MaximumLength != 0)) &&
            (String->Buffer == NULL)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }
	
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}