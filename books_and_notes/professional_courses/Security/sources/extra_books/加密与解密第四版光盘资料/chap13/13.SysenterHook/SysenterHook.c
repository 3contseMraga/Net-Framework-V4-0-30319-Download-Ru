/*-----------------------------------------------------------------------
第13章  Hook技术
《加密与解密（第四版）》
(c)  看雪学院 www.kanxue.com 2000-2018
-----------------------------------------------------------------------*/


/*

  SysenterHook.C

  Author: achillis
  Last Updated: 2006-03-23

  This framework is generated by EasySYS 0.3.0
  This template file is copying from QuickSYS 0.3.0 written by Chunhua Liu

*/

#include "dbghelp.h"
#include "SysenterHook.h"

typedef unsigned char BYTE;
typedef LONG BOOL;

#define IA32_SYSENTER_EIP (0x176)
// Device driver routine declarations.
//

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	);

NTSTATUS
SysenterhookDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
SysenterhookDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
SysenterhookDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

VOID
SysenterhookUnload(
	IN PDRIVER_OBJECT		DriverObject
	);

BOOL InstallSysenterHook();
VOID UnInstallSysenterHook();
VOID My_KiFastCallEntry();
__int64 ReadMsr(ULONG MsrReg);
VOID WriteMsr(ULONG MsrReg,__int64 NewMsrValue);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SysenterhookDispatchCreate)
#pragma alloc_text(PAGE, SysenterhookDispatchClose)
#pragma alloc_text(PAGE, SysenterhookDispatchDeviceControl)
#pragma alloc_text(PAGE, SysenterhookUnload)
#endif // ALLOC_PRAGMA

BYTE *g_JmpStub = NULL;
ULONG g_OriginalFastCallEntryAddr = 0 ;

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	)
{
	//
    // Create dispatch points for device control, create, close.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = SysenterhookDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = SysenterhookDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SysenterhookDispatchDeviceControl;
    DriverObject->DriverUnload                         = SysenterhookUnload;
	
	InstallSysenterHook();
	DbgPrint("[SysenterHook] Loaded!\n");
    return STATUS_SUCCESS;
}

NTSTATUS
SysenterhookDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[SysenterHook] IRP_MJ_CREATE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
SysenterhookDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[SysenterHook] IRP_MJ_CLOSE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
SysenterhookDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	dprintf("[SysenterHook] IRP_MJ_DEVICE_CONTROL\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

VOID
SysenterhookUnload(
	IN PDRIVER_OBJECT		DriverObject
	)
{
	if (g_JmpStub != NULL && *g_JmpStub != 0)
	{
		UnInstallSysenterHook();
	}
    DbgPrint("[SysenterHook] Unloaded\n");
}

BOOL InstallSysenterHook()
{
	g_JmpStub = (BYTE*)ExAllocatePool(NonPagedPool,5);
	if (g_JmpStub == NULL)
	{
		return FALSE;
	}
	
	//填充JmpStub
	g_JmpStub[0] = 0xE9;
	*(ULONG*)(g_JmpStub+1) = (ULONG)My_KiFastCallEntry - (ULONG)g_JmpStub - 5;
	
	g_OriginalFastCallEntryAddr = (ULONG)ReadMsr(IA32_SYSENTER_EIP); //得到KiFastCallEntry地址
	DbgPrint("KiFastCallEntry Addr = 0x%08X\n",g_OriginalFastCallEntryAddr);
	
	//写入新的EIP地址为JmpStub,JmpStub再跳到My_KiFastCallEntry
	//之所以这么做，是因为KiFastCallEntry调用太频繁，卸载时这片内存不释放，避免直接跳到驱动中在驱动卸载时造成内存访问失败
	DbgPrint("new SYSENTER Addr = 0x%08X\n",g_JmpStub);
	WriteMsr(IA32_SYSENTER_EIP,(__int64)g_JmpStub);

	return TRUE;
}

__int64 ReadMsr(ULONG MsrReg)
{
	LARGE_INTEGER liValue;
	__asm
	{
		mov ecx,MsrReg
		rdmsr
		mov liValue.LowPart,eax  //得到KiFastCallEntry地址
		mov liValue.HighPart,edx
	}
	return liValue.QuadPart;
}

VOID WriteMsr(ULONG MsrReg,__int64 NewMsrValue)
{
	LARGE_INTEGER liValue ;
	liValue.QuadPart = NewMsrValue ;
	__asm
    {
		mov ecx, MsrReg
		mov edx,liValue.HighPart
		mov eax,liValue.LowPart   // Hook function address
		wrmsr					  // Write to the IA32_SYSENTER_EIP register
    }
}

VOID UnInstallSysenterHook()
{
	WriteMsr(IA32_SYSENTER_EIP,(__int64)g_OriginalFastCallEntryAddr);
}


//本函数只实现了基本的Hook框架用于演示SysenterHook
//如果要完成更复杂的功能，建议参考360等对KiFastCallEntry的Hook，以减少自身的工作量
__declspec(naked) VOID My_KiFastCallEntry()
{
	__asm
	{
		jmp g_OriginalFastCallEntryAddr
	}
}