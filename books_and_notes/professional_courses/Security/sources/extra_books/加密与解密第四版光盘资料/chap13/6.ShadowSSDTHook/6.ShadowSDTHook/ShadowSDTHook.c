/*-----------------------------------------------------------------------
第13章  Hook技术
《加密与解密（第四版）》
(c)  看雪学院 www.kanxue.com 2000-2018
-----------------------------------------------------------------------*/


/*

  ShadowSDTHook.C

  Author: achillis
  Last Updated: 2016-02-23

  This framework is generated by EasySYS 0.3.0
  This template file is copying from QuickSYS 0.3.0 written by Chunhua Liu

*/

#include "dbghelp.h"
#include "ShadowSDTHook.h"
#include "ntifs.h"
#include "myKernel.h"
//
// A structure representing the instance information associated with
// a particular device
//

typedef struct _DEVICE_EXTENSION
{
    ULONG  StateVariable;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef HWND
(*pfnNtUserFindWindowEx)(
						 HWND  hwndParent,
						 HWND  hwndChildAfter,
						 PUNICODE_STRING  ucClassName,
						 PUNICODE_STRING  ucWindowName,
						 DWORD dwUnknown
						 );

typedef BOOL
(*pfnNtUserPostMessage)(
						HWND hWnd,
						UINT Msg,
						WPARAM wParam,
						LPARAM lParam
						);

typedef NTSTATUS
(*pfnNtUserBuildHwndList)(
						  HDESK hDesktop,
						  HWND hwndParent,
						  BOOLEAN bChildren,
						  ULONG dwThreadId,
						  ULONG lParam,
						  HWND* pWnd,
						  PULONG pBufSize
						  );

typedef HWND
(*pfnNtUserGetForegroundWindow)(VOID);

typedef DWORD
(*pfnNtUserQueryWindow)(
						HWND hWnd,
						DWORD Index
						);

typedef HWND
(*pfnNtUserWindowFromPoint)(
							LONG X,
							LONG Y
							);

typedef BOOL
(*pfnNtUserPostThreadMessage)(
							  DWORD idThread,
							  UINT Msg,
							  WPARAM wParam,
							  LPARAM lParam
							  );

typedef HWND
(*pfnNtUserSetParent)(
					  HWND hWndChild,
					  HWND hWndoldParent
	);

HWND
DetourNtUserFindWindowEx(
					  HWND  hwndParent,
					  HWND  hwndChildAfter,
					  PUNICODE_STRING  ucClassName,
					  PUNICODE_STRING  ucWindowName,
					  DWORD dwUnknown
					  );

BOOL
DetourNtUserPostMessage(
					 HWND hWnd,
					 UINT Msg,
					 WPARAM wParam,
					 LPARAM lParam
					 );

NTSTATUS
DetourNtUserBuildHwndList(
					   HDESK hDesktop,
					   HWND hwndParent,
					   BOOLEAN bChildren,
					   ULONG dwThreadId,
					   ULONG lParam,
					   HWND* pWnd,
					   PULONG pBufSize
					   );

HWND
DetourNtUserGetForegroundWindow(VOID);

DWORD
DetourNtUserQueryWindow(
					 HWND hWnd,
					 DWORD Index
					 );

HWND
DetourNtUserWindowFromPoint(
						 LONG X,
						 LONG Y
						 );

BOOL
DetourNtUserPostThreadMessage(
						   DWORD idThread,
						   UINT Msg,
						   WPARAM wParam,
						   LPARAM lParam
						   );

HWND
DetourNtUserSetParent(
				   HWND hWndChild,
				   HWND hWndNewParent
	);

//只是调用了SearchShadowSSDT而已
BOOL GetShdowSSDTAddr(void);
//获取Csrss.exe的pid,为Hook/Unhook Shadow SSDT做准备
HANDLE GetCsrssPid(void);
//从KeAddSystemServiceTable中搜索Shadow SSDT的地址
ULONG SearchShadowSSDT(void);
//根据不同系统版本设置Shadow SSDT中几个要Hook的函数的索引
ULONG SetShdowSSDTFunID(void);
VOID InstallShadowSSDTHook();
VOID UnInstallShadowSSDTHook();

char* GetSystemHandleInfo(SYSTEM_INFORMATION_CLASS SystemInformationClass);

//
// Device driver routine declarations.
//

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	);

NTSTATUS
ShadowsdthookDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
ShadowsdthookDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
ShadowsdthookDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

VOID
ShadowsdthookUnload(
	IN PDRIVER_OBJECT		DriverObject
	);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, ShadowsdthookDispatchCreate)
#pragma alloc_text(PAGE, ShadowsdthookDispatchClose)
#pragma alloc_text(PAGE, ShadowsdthookDispatchDeviceControl)
#pragma alloc_text(PAGE, ShadowsdthookUnload)
#endif // ALLOC_PRAGMA

ULONG g_NtBuildNumber; 
PEPROCESS csrssEPROCESS; 
PSERVICE_DESCRIPTOR_TABLE_SHADOW pKeServiceDescriptorTableShadow; 
//保存原始cr0的值
ULONG g_OriginalCr0; 
//Shadow SSDT中相关函数的索引
ULONG IdNtUserFindWindowEx; 
ULONG IdNtUserGetForegroundWindow; 
ULONG IdNtUserQueryWindow; 
ULONG IdNtUserBuildHwndList; 
ULONG IdNtUserPostThreadMessage; 
ULONG IdNtUserWindowFromPoint; 
ULONG IdNtUserPostMessage; 
ULONG IdNtUserSetParent;

//函数变量声明
pfnNtUserWindowFromPoint  oldNtUserWindowFromPoint; 
pfnNtUserPostThreadMessage oldNtUserPostThreadMessage; 
pfnNtUserSetParent oldNtUserSetParent; 
pfnNtUserGetForegroundWindow oldNtUserGetForcegroundWindow; 
pfnNtUserQueryWindow oldNtUserQueryWindow; 
pfnNtUserPostMessage oldNtUserPostMessage; 
pfnNtUserBuildHwndList oldNtUserBuildHwndList; 
pfnNtUserFindWindowEx oldNtUserFindWindowEx; 

//Hook安装标记
BOOL g_IsShadowSSDTHooked = FALSE ;
//Hook总开关
BOOL g_ProtectOn = FALSE;
//被保护进程
HANDLE g_PidToProtect ;
HANDLE g_TidToProtect ;
HWND LastTopWindowHandle; 

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	)
{
	NTSTATUS			status = STATUS_SUCCESS;    
    UNICODE_STRING		ntDeviceName;
	UNICODE_STRING		dosDeviceName;
    PDEVICE_EXTENSION	deviceExtension;
	PDEVICE_OBJECT		deviceObject = NULL;
	BOOLEAN				fSymbolicLink = FALSE;

    dprintf("[ShadowSDTHook] DriverEntry: %wZ\n", RegistryPath);

    //
    // A real driver would:
    //
    //     1. Report it's resources (IoReportResourceUsage)
    //
    //     2. Attempt to locate the device(s) it supports

    //
    // OK, we've claimed our resources & found our h/w, so create
    // a device and initialize stuff...
    //

    RtlInitUnicodeString(&ntDeviceName, SHADOWSDTHOOK_DEVICE_NAME_W);

    //
    // Create an EXCLUSIVE device, i.e. only 1 thread at a time can send
    // i/o requests.
    //

    status = IoCreateDevice(
		DriverObject,
		sizeof(DEVICE_EXTENSION), // DeviceExtensionSize
		&ntDeviceName, // DeviceName
		FILE_DEVICE_SHADOWSDTHOOK, // DeviceType
		0, // DeviceCharacteristics
		TRUE, // Exclusive
		&deviceObject // [OUT]
		);

    if (!NT_SUCCESS(status))
	{
		dprintf("[ShadowSDTHook] IoCreateDevice = 0x%x\n", status);
		goto __failed;
	}

	deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

	//
	// Set up synchronization objects, state info,, etc.
	//

    //
    // Create a symbolic link that Win32 apps can specify to gain access
    // to this driver/device
    //

    RtlInitUnicodeString(&dosDeviceName, SHADOWSDTHOOK_DOS_DEVICE_NAME_W);

    status = IoCreateSymbolicLink(&dosDeviceName, &ntDeviceName);

    if (!NT_SUCCESS(status))
    {
        dprintf("[ShadowSDTHook] IoCreateSymbolicLink = 0x%x\n", status);
		goto __failed;
    }

	fSymbolicLink = TRUE;

    //
    // Create dispatch points for device control, create, close.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = ShadowsdthookDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = ShadowsdthookDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ShadowsdthookDispatchDeviceControl;
    DriverObject->DriverUnload                         = ShadowsdthookUnload;
	
	PsGetVersion(0, 0, &g_NtBuildNumber, 0);
	GetShdowSSDTAddr();
	SetShdowSSDTFunID();
	InstallShadowSSDTHook();

    if (NT_SUCCESS(status))
	    return status;

__failed:

	if (fSymbolicLink)
		IoDeleteSymbolicLink(&dosDeviceName);

	if (deviceObject)
		IoDeleteDevice(deviceObject);

	return status;
}

NTSTATUS
ShadowsdthookDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[ShadowSDTHook] IRP_MJ_CREATE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
ShadowsdthookDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[ShadowSDTHook] IRP_MJ_CLOSE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
ShadowsdthookDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS			status = STATUS_SUCCESS;
    PIO_STACK_LOCATION	irpStack;
    PDEVICE_EXTENSION	deviceExtension;
    PVOID				ioBuf;
    ULONG				inBufLength, outBufLength;
	ULONG				ioControlCode;
	PCLIENT_ID			pCid;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    Irp->IoStatus.Information = 0;

    //
    // Get the pointer to the input/output buffer and it's length
    //

    ioBuf = Irp->AssociatedIrp.SystemBuffer;
    inBufLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outBufLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

    switch (ioControlCode)
    {
	case IOCTL_SHADOWSDTHOOK_ENABLEPROT:
		{
			g_ProtectOn = TRUE ;
			status = STATUS_SUCCESS ;
			DbgPrint("[ShadowSDTHook] 已设置Shadow保护为开启状态!\n");
            break;
		}
	case IOCTL_SHADOWSDTHOOK_DISABLEPROT:
		{
			g_ProtectOn = FALSE ;
			status = STATUS_SUCCESS ;
			DbgPrint("[ShadowSDTHook] 已设置Shadow保护为关闭状态!\n");
            break;
		}
	case IOCTL_SHADOWSDTHOOK_SETTRUSTPROC:
		{
			if (inBufLength == sizeof(CLIENT_ID))
			{
				pCid = (PCLIENT_ID)ioBuf;
				g_PidToProtect = pCid->UniqueProcess ;
				g_TidToProtect = pCid->UniqueThread ;
				DbgPrint("[ShadowSDTHook] 设置被保护进程 Pid = %d  Tid = %d\n",g_PidToProtect,g_TidToProtect);
				status = STATUS_SUCCESS ;
			}
			break;
		}
		
    default:
        status = STATUS_INVALID_PARAMETER;
		
        dprintf("[ShadowSDTHook] unknown IRP_MJ_DEVICE_CONTROL = 0x%x (%04x,%04x)\n",
			ioControlCode, DEVICE_TYPE_FROM_CTL_CODE(ioControlCode),
			IoGetFunctionCodeFromCtlCode(ioControlCode));
		
        break;
	}

    //
    // DON'T get cute and try to use the status field of
    // the irp in the return status.  That IRP IS GONE as
    // soon as you call IoCompleteRequest.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // We never have pending operation so always return the status code.
    //

    return status;
}

VOID
ShadowsdthookUnload(
	IN PDRIVER_OBJECT		DriverObject
	)
{
    UNICODE_STRING dosDeviceName;

	//
    // Free any resources
    //
	if (g_IsShadowSSDTHooked)
	{
		UnInstallShadowSSDTHook();
	}

    //
    // Delete the symbolic link
    //

    RtlInitUnicodeString(&dosDeviceName, SHADOWSDTHOOK_DOS_DEVICE_NAME_W);

    IoDeleteSymbolicLink(&dosDeviceName);

    //
    // Delete the device object
    //

    IoDeleteDevice(DriverObject->DeviceObject);

    DbgPrint("[ShadowSDTHook] Unloaded\n");
}

ULONG SearchShadowSSDT()
{
	char *pfn; 
	ULONG addr; 
	int len; 
	//从KeAddSystemServiceTable中搜索Shadow SSDT,不错的方法
	pfn =(char*)KeAddSystemServiceTable;
	len = 0;
	while ( len < 0x1000 )
	{
		addr = *(ULONG*)pfn;
		if ( MmIsAddressValid((PVOID)addr) )   // KeAddSystemServiceTable中搜索有效地址
		{
			if ( *(ULONG*)addr == (ULONG)(KeServiceDescriptorTable->ServiceTable)
				&& addr != (ULONG)KeServiceDescriptorTable )
				return addr;
		}
		++len;
		pfn = pfn + 1;
	}
	return 0;
}

BOOL GetShdowSSDTAddr()
{
	ULONG addr; 
	
	addr = SearchShadowSSDT();
	pKeServiceDescriptorTableShadow = (PSERVICE_DESCRIPTOR_TABLE_SHADOW)addr;
	return addr != 0;
}


ULONG  SetShdowSSDTFunID()
{
	ULONG result;
	//Set Shadow SSDT Function ID
	result = g_NtBuildNumber;
	switch ( g_NtBuildNumber )
	{
	case 2600:                                                // WinXP
		IdNtUserFindWindowEx = 0x17Au;
		IdNtUserGetForegroundWindow = 0x194u;
		IdNtUserBuildHwndList = 0x138u;
		IdNtUserQueryWindow = 0x1E3u;
		IdNtUserWindowFromPoint = 0x250u;
		IdNtUserPostMessage = 0x1DBu;
		IdNtUserSetParent = 0x211u;
		IdNtUserPostThreadMessage = 0x1DCu;
		break;
    case 3790:                                                // win2003
		IdNtUserFindWindowEx = 0x179u;
		IdNtUserGetForegroundWindow = 0x193u;
		IdNtUserBuildHwndList = 0x137u;
		IdNtUserQueryWindow = 0x1E1u;
		IdNtUserWindowFromPoint = 0x24Cu;
		IdNtUserPostThreadMessage = 0x1DBu;
		IdNtUserPostMessage = 0x1DAu;
		IdNtUserSetParent = 0x20Eu;
		break;
    case 6000:                                               // Vista
		IdNtUserFindWindowEx = 0x187u;
		IdNtUserGetForegroundWindow = 0x1A2u;
		IdNtUserBuildHwndList = 0x142u;
		IdNtUserQueryWindow = 0x1F8u;
		IdNtUserWindowFromPoint = 0x269u;
		IdNtUserPostMessage = 0x1F1u;
		IdNtUserSetParent = 0x226u;
		IdNtUserPostThreadMessage = 0x1F2u;
	case 7600:
	case 7601:												//Win7 sp1
		IdNtUserFindWindowEx = 0x18Cu;
		IdNtUserGetForegroundWindow = 0x1A7u;
		IdNtUserBuildHwndList = 0x143u;
		IdNtUserQueryWindow = 0x203u;
		IdNtUserWindowFromPoint = 0x275u;
		IdNtUserPostMessage = 0x1FCu;
		IdNtUserSetParent = 0x230u;
		IdNtUserPostThreadMessage = 0x1FDu;
		break;
	case 9200:												//Win8
		IdNtUserFindWindowEx = 0x1CBu;
		IdNtUserGetForegroundWindow = 0x1ADu;
		IdNtUserBuildHwndList = 0x168u;
		IdNtUserQueryWindow = 0x1E2u;
		IdNtUserWindowFromPoint = 0x289u;
		IdNtUserPostMessage = 0x1EAu;
		IdNtUserSetParent = 0x24Eu;
		IdNtUserPostThreadMessage = 0x1E9u;
		break;
	case 9600:												//Win8.1
		IdNtUserFindWindowEx = 0x1CCu;
		IdNtUserGetForegroundWindow = 0x1AEu;
		IdNtUserBuildHwndList = 0x16Au;
		IdNtUserQueryWindow = 0x1E3u;
		IdNtUserWindowFromPoint = 0x28Du;
		IdNtUserPostMessage = 0x1ECu;
		IdNtUserSetParent = 0x251u;
		IdNtUserPostThreadMessage = 0x1EBu;
		break;
	}
	return result;
}


VOID InstallShadowSSDTHook()
{
	NTSTATUS status  = STATUS_SUCCESS ;
	status = PsLookupProcessByProcessId(GetCsrssPid(), &csrssEPROCESS);
	if (NT_SUCCESS(status))
	{
		KeAttachProcess(csrssEPROCESS);
		if ( pKeServiceDescriptorTableShadow
			&& IdNtUserFindWindowEx
			&& IdNtUserGetForegroundWindow
			&& IdNtUserBuildHwndList
			&& IdNtUserQueryWindow
			&& IdNtUserPostMessage
			&& IdNtUserPostThreadMessage
			&& IdNtUserSetParent
			&& IdNtUserWindowFromPoint )
		{
			oldNtUserFindWindowEx =(pfnNtUserFindWindowEx) pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserFindWindowEx];
			oldNtUserQueryWindow  = (pfnNtUserQueryWindow)  pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserQueryWindow];
			oldNtUserBuildHwndList = (pfnNtUserBuildHwndList)pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserBuildHwndList];
			oldNtUserGetForcegroundWindow =(pfnNtUserGetForegroundWindow)pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserGetForegroundWindow];
			oldNtUserWindowFromPoint = (pfnNtUserWindowFromPoint)pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserWindowFromPoint];
			oldNtUserPostThreadMessage = (pfnNtUserPostThreadMessage)pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserPostThreadMessage];
			oldNtUserPostMessage = (pfnNtUserPostMessage)pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserPostMessage];
			oldNtUserSetParent = (pfnNtUserSetParent)pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserSetParent];
			WPOFF();
			pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserFindWindowEx]=DetourNtUserFindWindowEx;
			pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserQueryWindow]=DetourNtUserQueryWindow;
			pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserBuildHwndList]=DetourNtUserBuildHwndList;
			pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserGetForegroundWindow]= DetourNtUserGetForegroundWindow;
			pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserWindowFromPoint]= DetourNtUserWindowFromPoint;
			pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserPostThreadMessage]=DetourNtUserPostThreadMessage;
			pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserPostMessage]=DetourNtUserPostMessage;
			pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserSetParent]=DetourNtUserSetParent;
			WPON();
		}
		KeDetachProcess();
		g_IsShadowSSDTHooked = TRUE ;
	}
	else
	{
		DbgPrint("PsLookupProcessByProcessId() error\n");
	}
}

VOID UnInstallShadowSSDTHook()
{
	KeAttachProcess(csrssEPROCESS);
	WPOFF();
	if ( pKeServiceDescriptorTableShadow
		&& IdNtUserFindWindowEx
		&& IdNtUserGetForegroundWindow
		&& IdNtUserBuildHwndList
		&& IdNtUserQueryWindow
		&& IdNtUserPostMessage
		&& IdNtUserPostThreadMessage
		&& IdNtUserSetParent
		&& IdNtUserWindowFromPoint )
	{
		pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserFindWindowEx]=oldNtUserFindWindowEx;
		pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserQueryWindow]=oldNtUserQueryWindow;
		pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserBuildHwndList]=oldNtUserBuildHwndList;
		pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserGetForegroundWindow]= oldNtUserGetForcegroundWindow;
		pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserWindowFromPoint]= oldNtUserWindowFromPoint;
		pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserPostThreadMessage]=oldNtUserPostThreadMessage;
		pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserPostMessage]=oldNtUserPostMessage;
		pKeServiceDescriptorTableShadow->SSDTShadow.ServiceTable[IdNtUserSetParent]=oldNtUserSetParent;
	}
	WPON();
	KeDetachProcess();
}

HANDLE GetCsrssPid(void)
{
	char* pBuf; 
	HANDLE result; 
	PSYSTEM_HANDLE_INFORMATION pSysHandleInfo; 
	DWORD HandleCount; 
	HANDLE dwCsrssPid; 
	DWORD cnt; 
	OBJECT_ATTRIBUTES ObjectAttributes; 
	CLIENT_ID ClientId; 
	HANDLE hSourceProcess; 
	HANDLE Handle; 
	char ObjectInformation[0x400]; 
	PUNICODE_STRING namebuffer;
	BOOL bFound=FALSE;//自己加的标志
	//通过查找\\Windows\\ApiPort对象的所有者来确定Csrss.exe
	dwCsrssPid = 0;
	pBuf = GetSystemHandleInfo(SystemHandleInformation);
	if ( pBuf )
	{
		HandleCount = *(DWORD*)pBuf;
		cnt = 0;
		if ( HandleCount )
		{
			pSysHandleInfo = (PSYSTEM_HANDLE_INFORMATION)((char *)pBuf + 4);
			do
			{
				if ( pSysHandleInfo->ObjectTypeNumber == 21 )             // 21=OB_TYPE_PORT
				{
					ObjectAttributes.Length = 24;
					ObjectAttributes.RootDirectory = 0;
					ObjectAttributes.Attributes = 0x200u;
					ObjectAttributes.ObjectName = 0;
					ObjectAttributes.SecurityDescriptor = 0;
					ObjectAttributes.SecurityQualityOfService = 0;
					ClientId.UniqueProcess = (HANDLE)pSysHandleInfo->ProcessId;
					ClientId.UniqueThread = 0;
					if ( NtOpenProcess(&hSourceProcess, 0x40u, &ObjectAttributes, &ClientId) >= 0 )
					{
						if ( NT_SUCCESS(ZwDuplicateObject(
							hSourceProcess,
							(HANDLE)pSysHandleInfo->Handle,
							(HANDLE)0xFFFFFFFF,
							&Handle,
							0,
							0,
							DUPLICATE_SAME_ACCESS)))
						{
							if ( ZwQueryObject(Handle, ObjectNameInfo, &ObjectInformation, 0x100u, 0) >= 0 )
							{
								//下面这句是自己改的
								namebuffer=(PUNICODE_STRING)ObjectInformation;
								if ( namebuffer->Buffer)
								{
									if ( !wcsncmp(L"\\Windows\\ApiPort", namebuffer->Buffer, 16) )
									{
										dwCsrssPid =(HANDLE)(pSysHandleInfo->ProcessId);     // 偏移为0的地方即PID
										bFound=TRUE; //这是自己加的,原代码是遍历完所有句柄之后才退出
									}
								}
							}
							ZwClose(Handle);
						}
						ZwClose(hSourceProcess);
					}
				}
				if (bFound) break;//这一句也是后来加的
				++cnt;
				pSysHandleInfo ++;
			}
			while ( cnt < HandleCount);
		}
		ExFreePoolWithTag(pBuf, 0);
		result = dwCsrssPid;
	}
	else
	{
		result = 0;
	}
	return result;
}

char* GetSystemHandleInfo(SYSTEM_INFORMATION_CLASS SystemInformationClass)
{
	ULONG buflen; 
	char* buf; 
	NTSTATUS status;
	
	buflen = 0x4000;
	while ( 1 )
	{
		buf = ExAllocatePool(PagedPool, buflen);
		//这里稍有改动,应是先判断再清零
		if ( !buf )
			break;
		memset(buf, 0, buflen);
		status = ZwQuerySystemInformation(SystemHandleInformation, buf, buflen, 0);
		if ( status != STATUS_INFO_LENGTH_MISMATCH )
		{
			if ( !status )
				return buf;
			ExFreePoolWithTag(buf, 0);
			return 0;
		}
		ExFreePoolWithTag(buf, 0);
		buflen *= 2;
	}
	return 0;
}


HWND
DetourNtUserFindWindowEx(
					  HWND  hwndParent,
					  HWND  hwndChildAfter,
					  PUNICODE_STRING  ucClassName,
					  PUNICODE_STRING  ucWindowName,
					  DWORD dwUnknown
					  )
{
	HWND hWnd;
	HWND hWndResult;
	
	hWnd = oldNtUserFindWindowEx(hwndParent, hwndChildAfter, ucClassName, ucWindowName, dwUnknown);

	if (!g_ProtectOn)
	{
		//保护未开启，则直接返回原始结果
		return hWnd;
	}
	
	if ( PsGetCurrentProcessId() == (HANDLE)g_PidToProtect || (HANDLE)oldNtUserQueryWindow(hWnd, 0) != g_PidToProtect )
		hWndResult = hWnd;
	else
		hWndResult = 0;
	return hWndResult;
}

BOOL
DetourNtUserPostMessage(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	HANDLE curPid; 
	BOOL result; 
	
	if (!g_ProtectOn)
	{
		return oldNtUserPostMessage(hWnd, Msg, wParam, lParam);
	}

	curPid = (HANDLE)oldNtUserQueryWindow(hWnd, 0);
	if ( PsGetCurrentProcessId() == (HANDLE)g_PidToProtect || curPid != g_PidToProtect )
		result = oldNtUserPostMessage(hWnd, Msg, wParam, lParam);
	else
		result = 0;
	return result;
}


NTSTATUS
DetourNtUserBuildHwndList(
	HDESK hDesktop,
	HWND hwndParent,
	BOOLEAN bChildren,
	ULONG dwThreadId,
	ULONG lParam,
	HWND* pWnd,
	PULONG pBufSize)
{
  NTSTATUS result;
  ULONG Cnt; 
  ULONG i; 
  NTSTATUS status; 

  if (!g_ProtectOn)
  {
	  return oldNtUserBuildHwndList(hDesktop, hwndParent, bChildren, dwThreadId, lParam, pWnd, pBufSize);
  }

  if ( PsGetCurrentProcessId() == g_PidToProtect )
  {
    result = oldNtUserBuildHwndList(hDesktop, hwndParent, bChildren, dwThreadId, lParam, pWnd, pBufSize);
  }
  else
  {
    if ( bChildren != TRUE || oldNtUserQueryWindow(hwndParent, 0) != (DWORD)g_PidToProtect )
    {
      status = oldNtUserBuildHwndList(hDesktop, hwndParent, bChildren, dwThreadId, lParam, pWnd, pBufSize);
      if ( !status )
      {
        Cnt = 0;
        if ( *pBufSize )
        {
          do
          {
            if ( oldNtUserQueryWindow(pWnd[Cnt], 0) == (DWORD)g_PidToProtect )
            {
              for ( i = Cnt; i < *pBufSize - 1; i++ )
              {
				  pWnd[i] = pWnd[i + 1];// 把后面数据往前挪
              }
              pWnd[*pBufSize-1] = 0;    // 最后一项置0
			  *pBufSize=*pBufSize-1;	//总数减1
            }
            Cnt++;
          }
          while ( Cnt < *pBufSize );
        }
      }
      result = status;
    }
    else
    {
      result = STATUS_UNSUCCESSFUL;
    }
  }
  return result;
}


HWND
DetourNtUserGetForegroundWindow(VOID)
{
  HWND hTopWnd; 
  hTopWnd = oldNtUserGetForcegroundWindow();

  if (!g_ProtectOn)
  {
	  return hTopWnd;
  }

  if ( PsGetCurrentProcessId() != g_PidToProtect )
  {
    if ( (HANDLE)oldNtUserQueryWindow(hTopWnd, 0) == g_PidToProtect )           // QUERY_WINDOW_UNIQUE_PROCESS_ID
      hTopWnd = LastTopWindowHandle;
    else
      LastTopWindowHandle = hTopWnd;
  }
  return hTopWnd;
}


DWORD
DetourNtUserQueryWindow(
	HWND hWnd,
	DWORD Index)
{
	ULONG result;
	if (!g_ProtectOn)
	{
		return oldNtUserQueryWindow(hWnd, Index);
	}
	if ( PsGetCurrentProcessId() == g_PidToProtect || (HANDLE)oldNtUserQueryWindow(hWnd, 0) != g_PidToProtect )// QUERY_WINDOW_UNIQUE_PROCESS_ID
		result = oldNtUserQueryWindow(hWnd, Index);
	else
		result = 0;
	return result;
}


HWND
DetourNtUserWindowFromPoint(
	LONG X,
	LONG Y)
{
	HANDLE wndpid; 
	HWND hWndResult; 
	HWND hTmp;
	hTmp = oldNtUserWindowFromPoint(X, Y);
	
	if (!g_ProtectOn)
	{
		return hTmp;
	}
	wndpid = (HANDLE)oldNtUserQueryWindow(hTmp, 0);                       // 获取窗口所属的进程pid
	if ( PsGetCurrentProcessId() == (HANDLE)g_PidToProtect || wndpid != g_PidToProtect )
		hWndResult = hTmp;
	else
		hWndResult = 0;
	return hWndResult;
}


BOOL
DetourNtUserPostThreadMessage(
	DWORD idThread,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	BOOL result;
	if (!g_ProtectOn)
	{
		return oldNtUserPostThreadMessage(idThread, Msg, wParam, lParam);
	}

	if ( (HANDLE)idThread == g_TidToProtect )
		result = 0;
	else
		result = oldNtUserPostThreadMessage(idThread, Msg, wParam, lParam);
	return result;
}


HWND
DetourNtUserSetParent(
	HWND hWndChild,
	HWND hWndNewParent)
{
	HANDLE curWndPid;
	HWND hResult; 
	if (!g_ProtectOn)
	{
		return oldNtUserSetParent(hWndChild, hWndNewParent);
	}
	curWndPid = (HANDLE)oldNtUserQueryWindow(hWndChild, 0);               // 查窗口所属的进程
	if ( PsGetCurrentProcessId() == g_PidToProtect || curWndPid != g_PidToProtect )
		hResult = oldNtUserSetParent(hWndChild, hWndNewParent);
	else
		hResult = 0;
	return hResult;
}