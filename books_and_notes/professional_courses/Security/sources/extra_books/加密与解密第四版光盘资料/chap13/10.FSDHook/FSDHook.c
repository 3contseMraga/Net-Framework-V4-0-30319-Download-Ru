/*-----------------------------------------------------------------------
第13章  Hook技术
《加密与解密（第四版）》
(c)  看雪学院 www.kanxue.com 2000-2018
-----------------------------------------------------------------------*/


/*

  FSDHook.C

  Author: achillis
  Last Updated: 2006-03-23

  This framework is generated by EasySYS 0.3.0
  This template file is copying from QuickSYS 0.3.0 written by Chunhua Liu

*/

#include "dbghelp.h"
#include "FSDHook.h"
#include "ntifs.h"
#include "myKernel.h"

// Device driver routine declarations.
//

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	);

NTSTATUS
FsdhookDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
FsdhookDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
FsdhookDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

VOID
FsdhookUnload(
	IN PDRIVER_OBJECT		DriverObject
	);

NTSTATUS
DetourNtfsFsdRead(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS GetNtfsMajorFunctionAddr();
BOOL InstallFSDHook();
VOID UnInstallFSDHook();

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, FsdhookDispatchCreate)
#pragma alloc_text(PAGE, FsdhookDispatchClose)
#pragma alloc_text(PAGE, FsdhookDispatchDeviceControl)
#pragma alloc_text(PAGE, FsdhookUnload)
#endif // ALLOC_PRAGMA


PDRIVER_DISPATCH *g_MajorFunAddrs = NULL;
PDRIVER_DISPATCH g_OriginalNtfsFsdRead = NULL ;

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	)
{
	//
    // Create dispatch points for device control, create, close.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = FsdhookDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = FsdhookDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = FsdhookDispatchDeviceControl;
    DriverObject->DriverUnload                         = FsdhookUnload;
	
	InstallFSDHook();
	DbgPrint("[FSDHook] Loaded!\n");
    return STATUS_SUCCESS;
}

NTSTATUS
FsdhookDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[FSDHook] IRP_MJ_CREATE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
FsdhookDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[FSDHook] IRP_MJ_CLOSE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
FsdhookDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	dprintf("[FSDHook] IRP_MJ_DEVICE_CONTROL\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

VOID
FsdhookUnload(
	IN PDRIVER_OBJECT		DriverObject
	)
{
	UnInstallFSDHook();
    DbgPrint("[FSDHook] Unloaded\n");
}

NTSTATUS GetNtfsMajorFunctionAddr()
{
	PDRIVER_OBJECT	pDriverObject;
	UNICODE_STRING	DeviceName;
	NTSTATUS		status;

	RtlInitUnicodeString(&DeviceName, L"\\FileSystem\\Ntfs");
	status = ObReferenceObjectByName(
		&DeviceName,
		OBJ_CASE_INSENSITIVE, 
		NULL, 
		0, 
		*IoDriverObjectType,
		KernelMode, 
		NULL, 
		(PVOID*)&pDriverObject);

	if(NT_SUCCESS(status))
	{
		g_MajorFunAddrs = pDriverObject->MajorFunction;
	}
	
	return status;
}


BOOL InstallFSDHook()
{
	NTSTATUS status = GetNtfsMajorFunctionAddr();
	if (NT_SUCCESS(status))
	{
		DbgPrint("Ntfs.sys MajorFun Arrary : 0x%X\n",g_MajorFunAddrs);
		//Hook
		g_OriginalNtfsFsdRead = (PDRIVER_DISPATCH)InterlockedExchange((volatile LONG*)&g_MajorFunAddrs[IRP_MJ_READ],(LONG)DetourNtfsFsdRead);
		DbgPrint("Ntfs!NtfsFsdRead hooked OK.\n");
		return TRUE;
	}

	return FALSE;
}

VOID UnInstallFSDHook()
{
	InterlockedExchange((volatile LONG*)&g_MajorFunAddrs[IRP_MJ_READ],(LONG)g_OriginalNtfsFsdRead);
	DbgPrint("Ntfs!NtfsFsdRead Unhooked OK.\n");
}

NTSTATUS
DetourNtfsFsdRead(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	char *szImageFileName = PsGetProcessImageFileName(PsGetCurrentProcess());
	NTSTATUS status = STATUS_SUCCESS;
	
	DbgPrint("[DetourNtfsFsdRead] 进程 %s 调用 Ntfs!NtfsFsdRead() .\n",szImageFileName);
	status = g_OriginalNtfsFsdRead(DeviceObject,Irp);
	
    return status;
}