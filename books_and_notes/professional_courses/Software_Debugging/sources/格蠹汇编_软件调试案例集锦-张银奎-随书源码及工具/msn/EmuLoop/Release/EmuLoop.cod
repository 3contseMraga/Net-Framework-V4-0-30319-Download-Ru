; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	c:\gedu\labs\msn\EmuLoop\EmuLoop.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BG@EIEDKDBL@Couldn?8t?5move?5to?5next?$AA@ ; `string'
PUBLIC	??_C@_07NINMPKLO@EmuLoop?$AA@			; `string'
PUBLIC	?FatalError@@YAXK@Z				; FatalError
EXTRN	__imp__MessageBoxA@16:PROC
;	COMDAT ??_C@_0BG@EIEDKDBL@Couldn?8t?5move?5to?5next?$AA@
; File c:\gedu\labs\msn\emuloop\emuloop.cpp
CONST	SEGMENT
??_C@_0BG@EIEDKDBL@Couldn?8t?5move?5to?5next?$AA@ DB 'Couldn''t move to n'
	DB	'ext', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07NINMPKLO@EmuLoop?$AA@
CONST	SEGMENT
??_C@_07NINMPKLO@EmuLoop?$AA@ DB 'EmuLoop', 00H		; `string'
; Function compile flags: /Ogsp
CONST	ENDS
_TEXT	SEGMENT
_ulErrCode$ = 8						; size = 4
?FatalError@@YAXK@Z PROC				; FatalError

; 22   :     MessageBox(NULL, "Couldn't move to next","EmuLoop", MB_OK);

  00000	6a 00		 push	 0
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_07NINMPKLO@EmuLoop?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EIEDKDBL@Couldn?8t?5move?5to?5next?$AA@
  0000c	6a 00		 push	 0
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 23   : }

  00014	c3		 ret	 0
?FatalError@@YAXK@Z ENDP				; FatalError
_TEXT	ENDS
PUBLIC	?GetPayloadAndMoveToNext@@YAPAXPAUMsgQueue@@@Z	; GetPayloadAndMoveToNext
; Function compile flags: /Ogsp
_TEXT	SEGMENT
_pMsgQueue$ = 8						; size = 4
?GetPayloadAndMoveToNext@@YAPAXPAUMsgQueue@@@Z PROC	; GetPayloadAndMoveToNext

; 26   : {

  00015	55		 push	 ebp
  00016	8b ec		 mov	 ebp, esp
  00018	56		 push	 esi
  00019	57		 push	 edi

; 27   :     MsgBlob * pCurrent=pMsgQueue->m_pCurMsgBlob;

  0001a	8b 7d 08	 mov	 edi, DWORD PTR _pMsgQueue$[ebp]
  0001d	8b 37		 mov	 esi, DWORD PTR [edi]

; 28   : 
; 29   :     if(pCurrent==NULL)

  0001f	85 f6		 test	 esi, esi
  00021	75 0b		 jne	 SHORT $LN1@GetPayload

; 30   :     {
; 31   :         FatalError(E_FAIL); // never return

  00023	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00028	e8 00 00 00 00	 call	 ?FatalError@@YAXK@Z	; FatalError
  0002d	59		 pop	 ecx
$LN1@GetPayload:

; 32   :     }
; 33   : 
; 34   :     pMsgQueue->m_pCurMsgBlob=pCurrent->pNext;

  0002e	8b 06		 mov	 eax, DWORD PTR [esi]
  00030	89 07		 mov	 DWORD PTR [edi], eax
  00032	5f		 pop	 edi

; 35   : 
; 36   :     return &(pCurrent->bPayload);

  00033	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00036	5e		 pop	 esi

; 37   : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?GetPayloadAndMoveToNext@@YAPAXPAUMsgQueue@@@Z ENDP	; GetPayloadAndMoveToNext
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_WinMain@16
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
_TEXT	SEGMENT
_queue$ = -20						; size = 4
_blob$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC

; 43   : {

  00039	55		 push	 ebp
  0003a	8b ec		 mov	 ebp, esp
  0003c	83 ec 14	 sub	 esp, 20			; 00000014H
  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00044	33 c5		 xor	 eax, ebp
  00046	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 44   :     MsgBlob   blob={NULL, 1, 'a'};

  00049	83 65 f0 00	 and	 DWORD PTR _blob$[ebp], 0

; 45   :     MsgQueue queue;
; 46   : 
; 47   :     queue.m_pCurMsgBlob=&blob;

  0004d	8d 45 f0	 lea	 eax, DWORD PTR _blob$[ebp]
  00050	89 45 ec	 mov	 DWORD PTR _queue$[ebp], eax

; 48   : 
; 49   :  	// TODO: Place code here.
; 50   :     GetPayloadAndMoveToNext(&queue);

  00053	8d 45 ec	 lea	 eax, DWORD PTR _queue$[ebp]
  00056	50		 push	 eax
  00057	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _blob$[ebp+4], 1
  0005e	c6 45 f8 61	 mov	 BYTE PTR _blob$[ebp+8], 97 ; 00000061H
  00062	e8 00 00 00 00	 call	 ?GetPayloadAndMoveToNext@@YAPAXPAUMsgQueue@@@Z ; GetPayloadAndMoveToNext
  00067	59		 pop	 ecx

; 51   :     
; 52   : 	return 0;
; 53   : }

  00068	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006b	33 cd		 xor	 ecx, ebp
  0006d	33 c0		 xor	 eax, eax
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	c9		 leave
  00075	c2 10 00	 ret	 16			; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
END
