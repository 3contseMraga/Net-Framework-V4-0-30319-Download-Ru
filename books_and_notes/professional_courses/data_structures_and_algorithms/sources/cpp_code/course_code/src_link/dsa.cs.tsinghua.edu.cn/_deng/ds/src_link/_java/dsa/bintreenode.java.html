<html>

<!-- Mirrored from dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/_java/dsa/bintreenode.java.htm by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 26 Aug 2019 00:58:00 GMT -->
<head>
<title>BinTreeNode.java</title>
<meta http-equiv="content-type" content="text/html; charset=GBK">
<style type="text/css">
<!--.line_num {color: #666666; background-color: #E8E8E8;}//-->
</style>
</head>
<body bgcolor=#FFFFFF text=#000000>
<pre style="font: 16pt consolas, 微软雅黑;"><b><p style="line-height: 150%">
<span class="line_num"><font color=#e8e8e8>000</font>1 </span><font color=#008000>/******************************************************************************************</font>
<span class="line_num"><font color=#e8e8e8>000</font>2 </span><font color=#008000> * Data Structures in C++</font>
<span class="line_num"><font color=#e8e8e8>000</font>3 </span><font color=#008000> * ISBN: 7-302-33064-6 & 7-302-33065-3 & 7-302-29652-2 & 7-302-26883-3</font>
<span class="line_num"><font color=#e8e8e8>000</font>4 </span><font color=#008000> * Junhui DENG, deng@tsinghua.edu.cn</font>
<span class="line_num"><font color=#e8e8e8>000</font>5 </span><font color=#008000> * Computer Science & Technology, Tsinghua University</font>
<span class="line_num"><font color=#e8e8e8>000</font>6 </span><font color=#008000> * Copyright (c) 2003-2019. All rights reserved.</font>
<span class="line_num"><font color=#e8e8e8>000</font>7 </span><font color=#008000> ******************************************************************************************/</font>
<span class="line_num"><font color=#e8e8e8>000</font>8 </span>
<span class="line_num"><font color=#e8e8e8>000</font>9 </span><font color=#008000>/*</font>
<span class="line_num"><font color=#e8e8e8>00</font>10 </span><font color=#008000> * 基于链表节点实现二叉树节点</font>
<span class="line_num"><font color=#e8e8e8>00</font>11 </span><font color=#008000> */</font>
<span class="line_num"><font color=#e8e8e8>00</font>12 </span>
<span class="line_num"><font color=#e8e8e8>00</font>13 </span><font color=#0000FF>package</font> dsa;
<span class="line_num"><font color=#e8e8e8>00</font>14 </span>
<span class="line_num"><font color=#e8e8e8>00</font>15 </span><font color=#0000FF>public</font> <font color=#0000FF>class</font> BinTreeNode <font color=#0000FF>implements</font> BinTreePosition {
<span class="line_num"><font color=#e8e8e8>00</font>16 </span>   <font color=#0000FF>protected</font> <font color=#0000FF>Object</font> <font color=#FF0000>element</font>;<font color=#008000>//该节点中存放的对象</font>
<span class="line_num"><font color=#e8e8e8>00</font>17 </span>   <font color=#0000FF>protected</font> BinTreePosition parent;<font color=#008000>//父亲</font>
<span class="line_num"><font color=#e8e8e8>00</font>18 </span>   <font color=#0000FF>protected</font> BinTreePosition lChild;<font color=#008000>//左孩子</font>
<span class="line_num"><font color=#e8e8e8>00</font>19 </span>   <font color=#0000FF>protected</font> BinTreePosition rChild;<font color=#008000>//右孩子</font>
<span class="line_num"><font color=#e8e8e8>00</font>20 </span>   <font color=#0000FF>protected</font>   <font color=#0000FF>int</font> size;<font color=#008000>//后代数目</font>
<span class="line_num"><font color=#e8e8e8>00</font>21 </span>   <font color=#0000FF>protected</font> <font color=#0000FF>int</font> height;<font color=#008000>//高度</font>
<span class="line_num"><font color=#e8e8e8>00</font>22 </span>   <font color=#0000FF>protected</font> <font color=#0000FF>int</font> depth;<font color=#008000>//深度</font>
<span class="line_num"><font color=#e8e8e8>00</font>23 </span>
<span class="line_num"><font color=#e8e8e8>00</font>24 </span><font color=#008000>   /**************************** 构造方法 ****************************/</font>
<span class="line_num"><font color=#e8e8e8>00</font>25 </span>   <font color=#0000FF>public</font> BinTreeNode()
<span class="line_num"><font color=#e8e8e8>00</font>26 </span>   { <font color=#0000FF>this</font>(<font color=#0000FF>null</font>, <font color=#0000FF>null</font>, <font color=#0000FF>true</font>, <font color=#0000FF>null</font>, <font color=#0000FF>null</font>); }
<span class="line_num"><font color=#e8e8e8>00</font>27 </span>
<span class="line_num"><font color=#e8e8e8>00</font>28 </span>   <font color=#0000FF>public</font> BinTreeNode(
<span class="line_num"><font color=#e8e8e8>00</font>29 </span>      <font color=#0000FF>Object</font> e,<font color=#008000>//节点内容</font>
<span class="line_num"><font color=#e8e8e8>00</font>30 </span>      BinTreePosition p,<font color=#008000>//父节点</font>
<span class="line_num"><font color=#e8e8e8>00</font>31 </span>      <font color=#0000FF>boolean</font> asLChild,<font color=#008000>//是否作为父节点的左孩子</font>
<span class="line_num"><font color=#e8e8e8>00</font>32 </span>      BinTreePosition l,<font color=#008000>//左孩子</font>
<span class="line_num"><font color=#e8e8e8>00</font>33 </span>      BinTreePosition r) { <font color=#008000>//右孩子</font>
<span class="line_num"><font color=#e8e8e8>00</font>34 </span>      size = 1; height = depth = 0; parent = lChild = rChild = <font color=#0000FF>null</font>;<font color=#008000>//初始化</font>
<span class="line_num"><font color=#e8e8e8>00</font>35 </span>      <font color=#FF0000>element</font> = e;<font color=#008000>//存放的对象</font>
<span class="line_num"><font color=#e8e8e8>00</font>36 </span><font color=#008000>      //建立与父亲的关系</font>
<span class="line_num"><font color=#e8e8e8>00</font>37 </span>      <font color=#0000FF>if</font> (<font color=#0000FF>null</font> != p)
<span class="line_num"><font color=#e8e8e8>00</font>38 </span>         <font color=#0000FF>if</font> (asLChild)  p.attachL(<font color=#0000FF>this</font>);
<span class="line_num"><font color=#e8e8e8>00</font>39 </span>         <font color=#0000FF>else</font>              p.attachR(<font color=#0000FF>this</font>);
<span class="line_num"><font color=#e8e8e8>00</font>40 </span><font color=#008000>      //建立与孩子的关系</font>
<span class="line_num"><font color=#e8e8e8>00</font>41 </span>      <font color=#0000FF>if</font> (<font color=#0000FF>null</font> != l) attachL(l);
<span class="line_num"><font color=#e8e8e8>00</font>42 </span>      <font color=#0000FF>if</font> (<font color=#0000FF>null</font> != r) attachR(r);
<span class="line_num"><font color=#e8e8e8>00</font>43 </span>   }
<span class="line_num"><font color=#e8e8e8>00</font>44 </span>
<span class="line_num"><font color=#e8e8e8>00</font>45 </span><font color=#008000>   /**************************** Position接口方法 ********************************/</font>
<span class="line_num"><font color=#e8e8e8>00</font>46 </span><font color=#008000>   //返回当前节点中存放的对象</font>
<span class="line_num"><font color=#e8e8e8>00</font>47 </span>   <font color=#0000FF>public</font> <font color=#0000FF>Object</font> getElem()
<span class="line_num"><font color=#e8e8e8>00</font>48 </span>   { <font color=#0000FF>return</font> <font color=#FF0000>element</font>; }
<span class="line_num"><font color=#e8e8e8>00</font>49 </span>
<span class="line_num"><font color=#e8e8e8>00</font>50 </span><font color=#008000>   //将对象obj存入当前节点，并返回此前的内容</font>
<span class="line_num"><font color=#e8e8e8>00</font>51 </span>   <font color=#0000FF>public</font> <font color=#0000FF>Object</font> setElem(<font color=#0000FF>Object</font> obj)
<span class="line_num"><font color=#e8e8e8>00</font>52 </span>   { <font color=#0000FF>Object</font> bak = <font color=#FF0000>element</font>; <font color=#FF0000>element</font> = obj; <font color=#0000FF>return</font> bak; }
<span class="line_num"><font color=#e8e8e8>00</font>53 </span>
<span class="line_num"><font color=#e8e8e8>00</font>54 </span><font color=#008000>   /**************************** BinTreePosition接口方法 *************************/</font>
<span class="line_num"><font color=#e8e8e8>00</font>55 </span><font color=#008000>   //判断是否有父亲（为使代码描述简洁）</font>
<span class="line_num"><font color=#e8e8e8>00</font>56 </span>   <font color=#0000FF>public</font> <font color=#0000FF>boolean</font> hasParent()
<span class="line_num"><font color=#e8e8e8>00</font>57 </span>   { <font color=#0000FF>return</font> <font color=#0000FF>null</font> != parent; }
<span class="line_num"><font color=#e8e8e8>00</font>58 </span><font color=#008000>   //返回当前节点的父节点</font>
<span class="line_num"><font color=#e8e8e8>00</font>59 </span>   <font color=#0000FF>public</font> BinTreePosition getParent()
<span class="line_num"><font color=#e8e8e8>00</font>60 </span>   { <font color=#0000FF>return</font> parent; }
<span class="line_num"><font color=#e8e8e8>00</font>61 </span><font color=#008000>   //设置当前节点的父节点</font>
<span class="line_num"><font color=#e8e8e8>00</font>62 </span>   <font color=#0000FF>public</font> <font color=#0000FF>void</font> setParent(BinTreePosition p)
<span class="line_num"><font color=#e8e8e8>00</font>63 </span>   { parent = p; }
<span class="line_num"><font color=#e8e8e8>00</font>64 </span>
<span class="line_num"><font color=#e8e8e8>00</font>65 </span><font color=#008000>   //判断是否为叶子</font>
<span class="line_num"><font color=#e8e8e8>00</font>66 </span>   <font color=#0000FF>public</font> <font color=#0000FF>boolean</font> isLeaf()
<span class="line_num"><font color=#e8e8e8>00</font>67 </span>   { <font color=#0000FF>return</font> !hasLChild() && !hasRChild(); }
<span class="line_num"><font color=#e8e8e8>00</font>68 </span>
<span class="line_num"><font color=#e8e8e8>00</font>69 </span><font color=#008000>   //判断是否为左孩子（为使代码描述简洁）</font>
<span class="line_num"><font color=#e8e8e8>00</font>70 </span><font color=#008000>   //若当前节点有父亲，而且是左孩子，则返回true；否则，返回false</font>
<span class="line_num"><font color=#e8e8e8>00</font>71 </span>   <font color=#0000FF>public</font> <font color=#0000FF>boolean</font> isLChild()
<span class="line_num"><font color=#e8e8e8>00</font>72 </span>   {  <font color=#0000FF>return</font> (hasParent() && <font color=#0000FF>this</font> == getParent().getLChild())  ? <font color=#0000FF>true</font> : <font color=#0000FF>false</font>; }
<span class="line_num"><font color=#e8e8e8>00</font>73 </span>
<span class="line_num"><font color=#e8e8e8>00</font>74 </span><font color=#008000>   //判断是否有左孩子（为使代码描述简洁）</font>
<span class="line_num"><font color=#e8e8e8>00</font>75 </span>   <font color=#0000FF>public</font> <font color=#0000FF>boolean</font> hasLChild()
<span class="line_num"><font color=#e8e8e8>00</font>76 </span>   { <font color=#0000FF>return</font> <font color=#0000FF>null</font> != lChild; }
<span class="line_num"><font color=#e8e8e8>00</font>77 </span><font color=#008000>   //返回当前节点的左孩子</font>
<span class="line_num"><font color=#e8e8e8>00</font>78 </span>   <font color=#0000FF>public</font> BinTreePosition getLChild()
<span class="line_num"><font color=#e8e8e8>00</font>79 </span>   { <font color=#0000FF>return</font> lChild; }
<span class="line_num"><font color=#e8e8e8>00</font>80 </span><font color=#008000>   //设置当前节点的左孩子（注意：this.lChild和c.parent都不一定为空）</font>
<span class="line_num"><font color=#e8e8e8>00</font>81 </span>   <font color=#0000FF>public</font> <font color=#0000FF>void</font> setLChild(BinTreePosition c)
<span class="line_num"><font color=#e8e8e8>00</font>82 </span>   { lChild = c; }
<span class="line_num"><font color=#e8e8e8>00</font>83 </span>
<span class="line_num"><font color=#e8e8e8>00</font>84 </span><font color=#008000>   //判断是否为右孩子（为使代码描述简洁）</font>
<span class="line_num"><font color=#e8e8e8>00</font>85 </span><font color=#008000>   //若当前节点有父亲，而且是右孩子，则返回true；否则，返回false</font>
<span class="line_num"><font color=#e8e8e8>00</font>86 </span>   <font color=#0000FF>public</font> <font color=#0000FF>boolean</font> isRChild()
<span class="line_num"><font color=#e8e8e8>00</font>87 </span>   {  <font color=#0000FF>return</font> (hasParent() && <font color=#0000FF>this</font> == getParent().getRChild())  ? <font color=#0000FF>true</font> : <font color=#0000FF>false</font>; }
<span class="line_num"><font color=#e8e8e8>00</font>88 </span><font color=#008000>   //判断是否有右孩子（为使代码描述简洁）</font>
<span class="line_num"><font color=#e8e8e8>00</font>89 </span>   <font color=#0000FF>public</font> <font color=#0000FF>boolean</font> hasRChild()
<span class="line_num"><font color=#e8e8e8>00</font>90 </span>   { <font color=#0000FF>return</font> <font color=#0000FF>null</font> != rChild; }
<span class="line_num"><font color=#e8e8e8>00</font>91 </span><font color=#008000>   //返回当前节点的右孩子</font>
<span class="line_num"><font color=#e8e8e8>00</font>92 </span>   <font color=#0000FF>public</font> BinTreePosition getRChild()
<span class="line_num"><font color=#e8e8e8>00</font>93 </span>   { <font color=#0000FF>return</font> rChild; }
<span class="line_num"><font color=#e8e8e8>00</font>94 </span><font color=#008000>   //设置当前节点的右孩子（注意：this.rChild和c.parent都不一定为空）</font>
<span class="line_num"><font color=#e8e8e8>00</font>95 </span>   <font color=#0000FF>public</font> <font color=#0000FF>void</font> setRChild(BinTreePosition c)
<span class="line_num"><font color=#e8e8e8>00</font>96 </span>   { rChild = c; }
<span class="line_num"><font color=#e8e8e8>00</font>97 </span>
<span class="line_num"><font color=#e8e8e8>00</font>98 </span><font color=#008000>   //返回当前节点后代元素的数目</font>
<span class="line_num"><font color=#e8e8e8>00</font>99 </span>   <font color=#0000FF>public</font> <font color=#0000FF>int</font> getSize()
<span class="line_num"><font color=#e8e8e8>0</font>100 </span>   { <font color=#0000FF>return</font> size; }
<span class="line_num"><font color=#e8e8e8>0</font>101 </span><font color=#008000>   //在孩子发生变化后，更新当前节点及其祖先的规模</font>
<span class="line_num"><font color=#e8e8e8>0</font>102 </span>   <font color=#0000FF>public</font> <font color=#0000FF>void</font> updateSize() {
<span class="line_num"><font color=#e8e8e8>0</font>103 </span>      size = 1;<font color=#008000>//当前节点</font>
<span class="line_num"><font color=#e8e8e8>0</font>104 </span>      <font color=#0000FF>if</font> (hasLChild())  size += getLChild().getSize();<font color=#008000>//左子树的规模</font>
<span class="line_num"><font color=#e8e8e8>0</font>105 </span>      <font color=#0000FF>if</font> (hasRChild())  size += getRChild().getSize();<font color=#008000>//右子树的规模</font>
<span class="line_num"><font color=#e8e8e8>0</font>106 </span>      <font color=#0000FF>if</font> (hasParent())  getParent().updateSize();<font color=#008000>//递归更新各个真祖先的规模记录</font>
<span class="line_num"><font color=#e8e8e8>0</font>107 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>108 </span>
<span class="line_num"><font color=#e8e8e8>0</font>109 </span><font color=#008000>   //返回当前节点的高度</font>
<span class="line_num"><font color=#e8e8e8>0</font>110 </span>   <font color=#0000FF>public</font> <font color=#0000FF>int</font> getHeight()
<span class="line_num"><font color=#e8e8e8>0</font>111 </span>   { <font color=#0000FF>return</font> height; }
<span class="line_num"><font color=#e8e8e8>0</font>112 </span><font color=#008000>   //在孩子发生变化后，更新当前节点及其祖先的高度</font>
<span class="line_num"><font color=#e8e8e8>0</font>113 </span>   <font color=#0000FF>public</font> <font color=#0000FF>void</font> updateHeight() {
<span class="line_num"><font color=#e8e8e8>0</font>114 </span>      height = 0;<font color=#008000>//先假设没有左、右孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>115 </span>      <font color=#0000FF>if</font> (hasLChild())  height = <font color=#0000FF>Math</font>.max(height, 1 + getLChild().getHeight()); <font color=#008000>//左孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>116 </span>      <font color=#0000FF>if</font> (hasRChild())  height = <font color=#0000FF>Math</font>.max(height, 1 + getRChild().getHeight()); <font color=#008000>//右孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>117 </span>      <font color=#0000FF>if</font> (hasParent())  getParent().updateHeight();<font color=#008000>//递归更新各个真祖先的高度记录</font>
<span class="line_num"><font color=#e8e8e8>0</font>118 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>119 </span>
<span class="line_num"><font color=#e8e8e8>0</font>120 </span><font color=#008000>   //返回当前节点的深度</font>
<span class="line_num"><font color=#e8e8e8>0</font>121 </span>   <font color=#0000FF>public</font> <font color=#0000FF>int</font> getDepth()
<span class="line_num"><font color=#e8e8e8>0</font>122 </span>   { <font color=#0000FF>return</font> depth; }
<span class="line_num"><font color=#e8e8e8>0</font>123 </span><font color=#008000>   //在父亲发生变化后，更新当前节点及其后代的深度</font>
<span class="line_num"><font color=#e8e8e8>0</font>124 </span>   <font color=#0000FF>public</font> <font color=#0000FF>void</font> updateDepth() {
<span class="line_num"><font color=#e8e8e8>0</font>125 </span>      depth = hasParent() ? 1 + getParent().getDepth() : 0; <font color=#008000>//当前节点</font>
<span class="line_num"><font color=#e8e8e8>0</font>126 </span>      <font color=#0000FF>if</font> (hasLChild())  getLChild().updateDepth();<font color=#008000>//沿孩子引用逐层向下，</font>
<span class="line_num"><font color=#e8e8e8>0</font>127 </span>      <font color=#0000FF>if</font> (hasRChild())  getRChild().updateDepth();<font color=#008000>//递归地更新所有后代的深度记录</font>
<span class="line_num"><font color=#e8e8e8>0</font>128 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>129 </span>
<span class="line_num"><font color=#e8e8e8>0</font>130 </span><font color=#008000>   //按照中序遍历的次序，找到当前节点的直接前驱</font>
<span class="line_num"><font color=#e8e8e8>0</font>131 </span>   <font color=#0000FF>public</font> BinTreePosition getPrev() {
<span class="line_num"><font color=#e8e8e8>0</font>132 </span><font color=#008000>      //若左子树非空，则其中的最大者即为当前节点的直接前驱</font>
<span class="line_num"><font color=#e8e8e8>0</font>133 </span>      <font color=#0000FF>if</font> (hasLChild())  <font color=#0000FF>return</font> findMaxDescendant(getLChild());
<span class="line_num"><font color=#e8e8e8>0</font>134 </span><font color=#008000>      //至此，当前节点没有左孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>135 </span>      <font color=#0000FF>if</font> (isRChild())   <font color=#0000FF>return</font> getParent();<font color=#008000>//若当前节点是右孩子，则父亲即为其直接前驱</font>
<span class="line_num"><font color=#e8e8e8>0</font>136 </span><font color=#008000>      //至此，当前节点没有左孩子，而且是左孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>137 </span>      BinTreePosition v = <font color=#0000FF>this</font>;<font color=#008000>//从当前节点出发</font>
<span class="line_num"><font color=#e8e8e8>0</font>138 </span>      <font color=#0000FF>while</font> (v.isLChild()) v = v.getParent();<font color=#008000>//沿左孩子链一直上升</font>
<span class="line_num"><font color=#e8e8e8>0</font>139 </span><font color=#008000>      //至此，v或者没有父亲，或者是父亲的右孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>140 </span>      <font color=#0000FF>return</font> v.getParent();
<span class="line_num"><font color=#e8e8e8>0</font>141 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>142 </span>
<span class="line_num"><font color=#e8e8e8>0</font>143 </span><font color=#008000>   //按照中序遍历的次序，找到当前节点的直接后继</font>
<span class="line_num"><font color=#e8e8e8>0</font>144 </span>   <font color=#0000FF>public</font> BinTreePosition getSucc() {
<span class="line_num"><font color=#e8e8e8>0</font>145 </span><font color=#008000>      //若右子树非空，则其中的最小者即为当前节点的直接后继</font>
<span class="line_num"><font color=#e8e8e8>0</font>146 </span>      <font color=#0000FF>if</font> (hasRChild())  <font color=#0000FF>return</font> findMinDescendant(getRChild());
<span class="line_num"><font color=#e8e8e8>0</font>147 </span><font color=#008000>      //至此，当前节点没有右孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>148 </span>      <font color=#0000FF>if</font> (isLChild())   <font color=#0000FF>return</font> getParent();<font color=#008000>//若当前节点是左孩子，则父亲即为其直接后继</font>
<span class="line_num"><font color=#e8e8e8>0</font>149 </span><font color=#008000>      //至此，当前节点没有右孩子，而且是右孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>150 </span>      BinTreePosition v = <font color=#0000FF>this</font>;<font color=#008000>//从当前节点出发</font>
<span class="line_num"><font color=#e8e8e8>0</font>151 </span>      <font color=#0000FF>while</font> (v.isRChild()) v = v.getParent();<font color=#008000>//沿右孩子链一直上升</font>
<span class="line_num"><font color=#e8e8e8>0</font>152 </span><font color=#008000>      //至此，v或者没有父亲，或者是父亲的左孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>153 </span>      <font color=#0000FF>return</font> v.getParent();
<span class="line_num"><font color=#e8e8e8>0</font>154 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>155 </span>
<span class="line_num"><font color=#e8e8e8>0</font>156 </span><font color=#008000>   //断绝当前节点与其父亲的父子关系</font>
<span class="line_num"><font color=#e8e8e8>0</font>157 </span><font color=#008000>   //返回当前节点</font>
<span class="line_num"><font color=#e8e8e8>0</font>158 </span>   <font color=#0000FF>public</font> BinTreePosition secede() {
<span class="line_num"><font color=#e8e8e8>0</font>159 </span>      <font color=#0000FF>if</font> (<font color=#0000FF>null</font> != parent)  {
<span class="line_num"><font color=#e8e8e8>0</font>160 </span>         <font color=#0000FF>if</font> (isLChild())   parent.setLChild(<font color=#0000FF>null</font>);<font color=#008000>//切断父亲指向当前节点的引用</font>
<span class="line_num"><font color=#e8e8e8>0</font>161 </span>         <font color=#0000FF>else</font>                 parent.setRChild(<font color=#0000FF>null</font>);
<span class="line_num"><font color=#e8e8e8>0</font>162 </span>         parent.updateSize();<font color=#008000>//更新当前节点及其祖先的规模</font>
<span class="line_num"><font color=#e8e8e8>0</font>163 </span>         parent.updateHeight();<font color=#008000>//更新当前节点及其祖先的高度</font>
<span class="line_num"><font color=#e8e8e8>0</font>164 </span>         parent = <font color=#0000FF>null</font>;<font color=#008000>//切断当前节点指向原父亲的引用</font>
<span class="line_num"><font color=#e8e8e8>0</font>165 </span>         updateDepth();<font color=#008000>//更新节点及其后代节点的深度</font>
<span class="line_num"><font color=#e8e8e8>0</font>166 </span>      }
<span class="line_num"><font color=#e8e8e8>0</font>167 </span>      <font color=#0000FF>return</font> <font color=#0000FF>this</font>;<font color=#008000>//返回当前节点</font>
<span class="line_num"><font color=#e8e8e8>0</font>168 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>169 </span>
<span class="line_num"><font color=#e8e8e8>0</font>170 </span><font color=#008000>   //将节点c作为当前节点的左孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>171 </span>   <font color=#0000FF>public</font> BinTreePosition attachL(BinTreePosition c) {
<span class="line_num"><font color=#e8e8e8>0</font>172 </span>      <font color=#0000FF>if</font> (hasLChild())  getLChild().secede();<font color=#008000>//摘除当前节点原先的左孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>173 </span>      <font color=#0000FF>if</font> (<font color=#0000FF>null</font> != c) {
<span class="line_num"><font color=#e8e8e8>0</font>174 </span>         c.secede();<font color=#008000>//c脱离原父亲</font>
<span class="line_num"><font color=#e8e8e8>0</font>175 </span>         lChild = c; c.setParent(<font color=#0000FF>this</font>);<font color=#008000>//确立新的父子关系</font>
<span class="line_num"><font color=#e8e8e8>0</font>176 </span>         updateSize();<font color=#008000>//更新当前节点及其祖先的规模</font>
<span class="line_num"><font color=#e8e8e8>0</font>177 </span>         updateHeight();<font color=#008000>//更新当前节点及其祖先的高度</font>
<span class="line_num"><font color=#e8e8e8>0</font>178 </span>         c.updateDepth();<font color=#008000>//更新c及其后代节点的深度</font>
<span class="line_num"><font color=#e8e8e8>0</font>179 </span>      }
<span class="line_num"><font color=#e8e8e8>0</font>180 </span>      <font color=#0000FF>return</font> <font color=#0000FF>this</font>;
<span class="line_num"><font color=#e8e8e8>0</font>181 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>182 </span>
<span class="line_num"><font color=#e8e8e8>0</font>183 </span><font color=#008000>   //将节点c作为当前节点的右孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>184 </span>   <font color=#0000FF>public</font> BinTreePosition attachR(BinTreePosition c) {
<span class="line_num"><font color=#e8e8e8>0</font>185 </span>      <font color=#0000FF>if</font> (hasRChild())  getRChild().secede();<font color=#008000>//摘除当前节点原先的右孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>186 </span>      <font color=#0000FF>if</font> (<font color=#0000FF>null</font> != c) {
<span class="line_num"><font color=#e8e8e8>0</font>187 </span>         c.secede();<font color=#008000>//c脱离原父亲</font>
<span class="line_num"><font color=#e8e8e8>0</font>188 </span>         rChild = c; c.setParent(<font color=#0000FF>this</font>);<font color=#008000>//确立新的父子关系</font>
<span class="line_num"><font color=#e8e8e8>0</font>189 </span>         updateSize();<font color=#008000>//更新当前节点及其祖先的规模</font>
<span class="line_num"><font color=#e8e8e8>0</font>190 </span>         updateHeight();<font color=#008000>//更新当前节点及其祖先的高度</font>
<span class="line_num"><font color=#e8e8e8>0</font>191 </span>         c.updateDepth();<font color=#008000>//更新c及其后代节点的深度</font>
<span class="line_num"><font color=#e8e8e8>0</font>192 </span>      }
<span class="line_num"><font color=#e8e8e8>0</font>193 </span>      <font color=#0000FF>return</font> <font color=#0000FF>this</font>;
<span class="line_num"><font color=#e8e8e8>0</font>194 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>195 </span>
<span class="line_num"><font color=#e8e8e8>0</font>196 </span><font color=#008000>   //前序遍历</font>
<span class="line_num"><font color=#e8e8e8>0</font>197 </span>   <font color=#0000FF>public</font> <font color=#FF0000>Iterator</font> elementsPreorder() {
<span class="line_num"><font color=#e8e8e8>0</font>198 </span>      <font color=#FF0000>List</font> <font color=#FF0000>list</font> = <font color=#0000FF>new</font> List_DLNode();
<span class="line_num"><font color=#e8e8e8>0</font>199 </span>      preorder(<font color=#FF0000>list</font>, <font color=#0000FF>this</font>);
<span class="line_num"><font color=#e8e8e8>0</font>200 </span>      <font color=#0000FF>return</font> <font color=#FF0000>list</font>.elements();
<span class="line_num"><font color=#e8e8e8>0</font>201 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>202 </span>
<span class="line_num"><font color=#e8e8e8>0</font>203 </span><font color=#008000>   //中序遍历</font>
<span class="line_num"><font color=#e8e8e8>0</font>204 </span>   <font color=#0000FF>public</font> <font color=#FF0000>Iterator</font> elementsInorder() {
<span class="line_num"><font color=#e8e8e8>0</font>205 </span>      <font color=#FF0000>List</font> <font color=#FF0000>list</font> = <font color=#0000FF>new</font> List_DLNode();
<span class="line_num"><font color=#e8e8e8>0</font>206 </span>      inorder(<font color=#FF0000>list</font>, <font color=#0000FF>this</font>);
<span class="line_num"><font color=#e8e8e8>0</font>207 </span>      <font color=#0000FF>return</font> <font color=#FF0000>list</font>.elements();
<span class="line_num"><font color=#e8e8e8>0</font>208 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>209 </span>
<span class="line_num"><font color=#e8e8e8>0</font>210 </span><font color=#008000>   //后序遍历</font>
<span class="line_num"><font color=#e8e8e8>0</font>211 </span>   <font color=#0000FF>public</font> <font color=#FF0000>Iterator</font> elementsPostorder() {
<span class="line_num"><font color=#e8e8e8>0</font>212 </span>      <font color=#FF0000>List</font> <font color=#FF0000>list</font> = <font color=#0000FF>new</font> List_DLNode();
<span class="line_num"><font color=#e8e8e8>0</font>213 </span>      postorder(<font color=#FF0000>list</font>, <font color=#0000FF>this</font>);
<span class="line_num"><font color=#e8e8e8>0</font>214 </span>      <font color=#0000FF>return</font> <font color=#FF0000>list</font>.elements();
<span class="line_num"><font color=#e8e8e8>0</font>215 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>216 </span>
<span class="line_num"><font color=#e8e8e8>0</font>217 </span><font color=#008000>   //层次遍历</font>
<span class="line_num"><font color=#e8e8e8>0</font>218 </span>   <font color=#0000FF>public</font> <font color=#FF0000>Iterator</font> elementsLevelorder() {
<span class="line_num"><font color=#e8e8e8>0</font>219 </span>      <font color=#FF0000>List</font> <font color=#FF0000>list</font> = <font color=#0000FF>new</font> List_DLNode();
<span class="line_num"><font color=#e8e8e8>0</font>220 </span>      levelorder(<font color=#FF0000>list</font>, <font color=#0000FF>this</font>);
<span class="line_num"><font color=#e8e8e8>0</font>221 </span>      <font color=#0000FF>return</font> <font color=#FF0000>list</font>.elements();
<span class="line_num"><font color=#e8e8e8>0</font>222 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>223 </span>
<span class="line_num"><font color=#e8e8e8>0</font>224 </span><font color=#008000>   /**************************** 辅助方法 ****************************/</font>
<span class="line_num"><font color=#e8e8e8>0</font>225 </span><font color=#008000>   //在v的后代中，找出最小者</font>
<span class="line_num"><font color=#e8e8e8>0</font>226 </span>   <font color=#0000FF>protected</font> <font color=#0000FF>static</font> BinTreePosition findMinDescendant(BinTreePosition v) {
<span class="line_num"><font color=#e8e8e8>0</font>227 </span>      <font color=#0000FF>if</font> (<font color=#0000FF>null</font> != v)
<span class="line_num"><font color=#e8e8e8>0</font>228 </span>         <font color=#0000FF>while</font> (v.hasLChild())   v = v.getLChild();<font color=#008000>//从v出发，沿左孩子链一直下降</font>
<span class="line_num"><font color=#e8e8e8>0</font>229 </span><font color=#008000>      //至此，v或者为空，或者没有左孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>230 </span>      <font color=#0000FF>return</font> v;
<span class="line_num"><font color=#e8e8e8>0</font>231 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>232 </span>
<span class="line_num"><font color=#e8e8e8>0</font>233 </span><font color=#008000>   //在v的后代中，找出最大者</font>
<span class="line_num"><font color=#e8e8e8>0</font>234 </span>   <font color=#0000FF>protected</font> <font color=#0000FF>static</font> BinTreePosition findMaxDescendant(BinTreePosition v) {
<span class="line_num"><font color=#e8e8e8>0</font>235 </span>      <font color=#0000FF>if</font> (<font color=#0000FF>null</font> != v)
<span class="line_num"><font color=#e8e8e8>0</font>236 </span>         <font color=#0000FF>while</font> (v.hasRChild()) v = v.getRChild();<font color=#008000>//从v出发，沿右孩子链一直下降</font>
<span class="line_num"><font color=#e8e8e8>0</font>237 </span><font color=#008000>      //至此，v或者为空，或者没有右孩子</font>
<span class="line_num"><font color=#e8e8e8>0</font>238 </span>      <font color=#0000FF>return</font> v;
<span class="line_num"><font color=#e8e8e8>0</font>239 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>240 </span>
<span class="line_num"><font color=#e8e8e8>0</font>241 </span><font color=#008000>   //前序遍历以v为根节的（子）树</font>
<span class="line_num"><font color=#e8e8e8>0</font>242 </span>   <font color=#0000FF>protected</font> <font color=#0000FF>static</font> <font color=#0000FF>void</font> preorder(<font color=#FF0000>List</font> <font color=#FF0000>list</font>, BinTreePosition v) {
<span class="line_num"><font color=#e8e8e8>0</font>243 </span>      <font color=#0000FF>if</font> (<font color=#0000FF>null</font> == v) <font color=#0000FF>return</font>;<font color=#008000>//递归基：空树</font>
<span class="line_num"><font color=#e8e8e8>0</font>244 </span>      <font color=#FF0000>list</font>.insertLast(v);<font color=#008000>//访问v</font>
<span class="line_num"><font color=#e8e8e8>0</font>245 </span>      preorder(<font color=#FF0000>list</font>, v.getLChild());<font color=#008000>//遍历左子树</font>
<span class="line_num"><font color=#e8e8e8>0</font>246 </span>      preorder(<font color=#FF0000>list</font>, v.getRChild());<font color=#008000>//遍历右子树</font>
<span class="line_num"><font color=#e8e8e8>0</font>247 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>248 </span>
<span class="line_num"><font color=#e8e8e8>0</font>249 </span><font color=#008000>   //中序遍历以v为根节的（子）树</font>
<span class="line_num"><font color=#e8e8e8>0</font>250 </span>   <font color=#0000FF>protected</font> <font color=#0000FF>static</font> <font color=#0000FF>void</font> inorder(<font color=#FF0000>List</font> <font color=#FF0000>list</font>, BinTreePosition v) {
<span class="line_num"><font color=#e8e8e8>0</font>251 </span>      <font color=#0000FF>if</font> (<font color=#0000FF>null</font> == v) <font color=#0000FF>return</font>;<font color=#008000>//递归基：空树</font>
<span class="line_num"><font color=#e8e8e8>0</font>252 </span>      inorder(<font color=#FF0000>list</font>, v.getLChild());<font color=#008000>//遍历左子树</font>
<span class="line_num"><font color=#e8e8e8>0</font>253 </span>      <font color=#FF0000>list</font>.insertLast(v);<font color=#008000>//访问v</font>
<span class="line_num"><font color=#e8e8e8>0</font>254 </span>      inorder(<font color=#FF0000>list</font>, v.getRChild());<font color=#008000>//遍历右子树</font>
<span class="line_num"><font color=#e8e8e8>0</font>255 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>256 </span>
<span class="line_num"><font color=#e8e8e8>0</font>257 </span><font color=#008000>   //后序遍历以v为根节的（子）树</font>
<span class="line_num"><font color=#e8e8e8>0</font>258 </span>   <font color=#0000FF>protected</font> <font color=#0000FF>static</font> <font color=#0000FF>void</font> postorder(<font color=#FF0000>List</font> <font color=#FF0000>list</font>, BinTreePosition v) {
<span class="line_num"><font color=#e8e8e8>0</font>259 </span>      <font color=#0000FF>if</font> (<font color=#0000FF>null</font> == v) <font color=#0000FF>return</font>;<font color=#008000>//递归基：空树</font>
<span class="line_num"><font color=#e8e8e8>0</font>260 </span>      postorder(<font color=#FF0000>list</font>, v.getLChild());<font color=#008000>//遍历左子树</font>
<span class="line_num"><font color=#e8e8e8>0</font>261 </span>      postorder(<font color=#FF0000>list</font>, v.getRChild());<font color=#008000>//遍历右子树</font>
<span class="line_num"><font color=#e8e8e8>0</font>262 </span>      <font color=#FF0000>list</font>.insertLast(v);<font color=#008000>//访问v</font>
<span class="line_num"><font color=#e8e8e8>0</font>263 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>264 </span>
<span class="line_num"><font color=#e8e8e8>0</font>265 </span><font color=#008000>   //层次遍历以v为根节的（子）树</font>
<span class="line_num"><font color=#e8e8e8>0</font>266 </span>   <font color=#0000FF>protected</font> <font color=#0000FF>static</font> <font color=#0000FF>void</font> levelorder(<font color=#FF0000>List</font> <font color=#FF0000>list</font>, BinTreePosition v) {
<span class="line_num"><font color=#e8e8e8>0</font>267 </span>      Queue_List  Q = <font color=#0000FF>new</font> Queue_List();<font color=#008000>//空队</font>
<span class="line_num"><font color=#e8e8e8>0</font>268 </span>      Q.enqueue(v);<font color=#008000>//根节点入队</font>
<span class="line_num"><font color=#e8e8e8>0</font>269 </span>      <font color=#0000FF>while</font> (!Q.isEmpty()) {
<span class="line_num"><font color=#e8e8e8>0</font>270 </span>         BinTreePosition u = (BinTreePosition) Q.dequeue();<font color=#008000>//出队</font>
<span class="line_num"><font color=#e8e8e8>0</font>271 </span>         <font color=#FF0000>list</font>.insertLast(u);<font color=#008000>//访问v</font>
<span class="line_num"><font color=#e8e8e8>0</font>272 </span>         <font color=#0000FF>if</font> (u.hasLChild())   Q.enqueue(u.getLChild());
<span class="line_num"><font color=#e8e8e8>0</font>273 </span>         <font color=#0000FF>if</font> (u.hasRChild())   Q.enqueue(u.getRChild());
<span class="line_num"><font color=#e8e8e8>0</font>274 </span>      }
<span class="line_num"><font color=#e8e8e8>0</font>275 </span>   }
<span class="line_num"><font color=#e8e8e8>0</font>276 </span>}
</b></p></pre>
</body>

<!-- Mirrored from dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/_java/dsa/bintreenode.java.htm by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 26 Aug 2019 00:58:00 GMT -->
</html>
